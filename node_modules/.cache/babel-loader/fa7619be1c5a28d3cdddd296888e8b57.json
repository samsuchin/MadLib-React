{"ast":null,"code":"/*!\n * Zfont v1.2.7\n * Text plugin for Zdog\n * 2019 James Daniel\n * MIT Licensed \n * github.com/jaames/zfont\n */\nvar Typr = {};\n\nTypr.parse = function (buff) {\n  var bin = Typr._bin;\n  var data = new Uint8Array(buff);\n  var offset = 0;\n  var sfnt_version = bin.readFixed(data, offset);\n  offset += 4;\n  var numTables = bin.readUshort(data, offset);\n  offset += 2;\n  var searchRange = bin.readUshort(data, offset);\n  offset += 2;\n  var entrySelector = bin.readUshort(data, offset);\n  offset += 2;\n  var rangeShift = bin.readUshort(data, offset);\n  offset += 2;\n  var tags = [\"cmap\", \"head\", \"hhea\", \"maxp\", \"hmtx\", \"name\", \"OS/2\", \"post\", \"loca\", \"glyf\", \"kern\", \"CFF \", \"GPOS\", \"GSUB\", \"SVG \"];\n  var obj = {\n    _data: data\n  };\n  var tabs = {};\n\n  for (var i = 0; i < numTables; i++) {\n    var tag = bin.readASCII(data, offset, 4);\n    offset += 4;\n    var checkSum = bin.readUint(data, offset);\n    offset += 4;\n    var toffset = bin.readUint(data, offset);\n    offset += 4;\n    var length = bin.readUint(data, offset);\n    offset += 4;\n    tabs[tag] = {\n      offset: toffset,\n      length: length\n    };\n  }\n\n  for (var i = 0; i < tags.length; i++) {\n    var t = tags[i];\n\n    if (tabs[t]) {\n      obj[t.trim()] = Typr[t.trim()].parse(data, tabs[t].offset, tabs[t].length, obj);\n    }\n  }\n\n  return obj;\n};\n\nTypr._tabOffset = function (data, tab) {\n  var bin = Typr._bin;\n  var numTables = bin.readUshort(data, 4);\n  var offset = 12;\n\n  for (var i = 0; i < numTables; i++) {\n    var tag = bin.readASCII(data, offset, 4);\n    offset += 4;\n    var checkSum = bin.readUint(data, offset);\n    offset += 4;\n    var toffset = bin.readUint(data, offset);\n    offset += 4;\n    var length = bin.readUint(data, offset);\n    offset += 4;\n\n    if (tag == tab) {\n      return toffset;\n    }\n  }\n\n  return 0;\n};\n\nTypr._bin = {\n  readFixed: function readFixed(data, o) {\n    return (data[o] << 8 | data[o + 1]) + (data[o + 2] << 8 | data[o + 3]) / (256 * 256 + 4);\n  },\n  readF2dot14: function readF2dot14(data, o) {\n    var num = Typr._bin.readShort(data, o);\n\n    return num / 16384;\n    var intg = num >> 14,\n        frac = (num & 16383) / (16383 + 1);\n    return intg > 0 ? intg + frac : intg - frac;\n  },\n  readInt: function readInt(buff, p) {\n    var a = Typr._bin.t.uint8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p];\n    return Typr._bin.t.int32[0];\n  },\n  readInt8: function readInt8(buff, p) {\n    var a = Typr._bin.t.uint8;\n    a[0] = buff[p];\n    return Typr._bin.t.int8[0];\n  },\n  readShort: function readShort(buff, p) {\n    var a = Typr._bin.t.uint8;\n    a[1] = buff[p];\n    a[0] = buff[p + 1];\n    return Typr._bin.t.int16[0];\n  },\n  readUshort: function readUshort(buff, p) {\n    return buff[p] << 8 | buff[p + 1];\n  },\n  readUshorts: function readUshorts(buff, p, len) {\n    var arr = [];\n\n    for (var i = 0; i < len; i++) {\n      arr.push(Typr._bin.readUshort(buff, p + i * 2));\n    }\n\n    return arr;\n  },\n  readUint: function readUint(buff, p) {\n    var a = Typr._bin.t.uint8;\n    a[3] = buff[p];\n    a[2] = buff[p + 1];\n    a[1] = buff[p + 2];\n    a[0] = buff[p + 3];\n    return Typr._bin.t.uint32[0];\n  },\n  readUint64: function readUint64(buff, p) {\n    return Typr._bin.readUint(buff, p) * (4294967295 + 1) + Typr._bin.readUint(buff, p + 4);\n  },\n  readASCII: function readASCII(buff, p, l) {\n    var s = \"\";\n\n    for (var i = 0; i < l; i++) {\n      s += String.fromCharCode(buff[p + i]);\n    }\n\n    return s;\n  },\n  readUnicode: function readUnicode(buff, p, l) {\n    var s = \"\";\n\n    for (var i = 0; i < l; i++) {\n      var c = buff[p++] << 8 | buff[p++];\n      s += String.fromCharCode(c);\n    }\n\n    return s;\n  },\n  _tdec: window[\"TextDecoder\"] ? new window[\"TextDecoder\"]() : null,\n  readUTF8: function readUTF8(buff, p, l) {\n    var tdec = Typr._bin._tdec;\n\n    if (tdec && p == 0 && l == buff.length) {\n      return tdec[\"decode\"](buff);\n    }\n\n    return Typr._bin.readASCII(buff, p, l);\n  },\n  readBytes: function readBytes(buff, p, l) {\n    var arr = [];\n\n    for (var i = 0; i < l; i++) {\n      arr.push(buff[p + i]);\n    }\n\n    return arr;\n  },\n  readASCIIArray: function readASCIIArray(buff, p, l) {\n    var s = [];\n\n    for (var i = 0; i < l; i++) {\n      s.push(String.fromCharCode(buff[p + i]));\n    }\n\n    return s;\n  }\n};\nTypr._bin.t = {\n  buff: new ArrayBuffer(8)\n};\nTypr._bin.t.int8 = new Int8Array(Typr._bin.t.buff);\nTypr._bin.t.uint8 = new Uint8Array(Typr._bin.t.buff);\nTypr._bin.t.int16 = new Int16Array(Typr._bin.t.buff);\nTypr._bin.t.uint16 = new Uint16Array(Typr._bin.t.buff);\nTypr._bin.t.int32 = new Int32Array(Typr._bin.t.buff);\nTypr._bin.t.uint32 = new Uint32Array(Typr._bin.t.buff);\nTypr._lctf = {};\n\nTypr._lctf.parse = function (data, offset, length, font, subt) {\n  var bin = Typr._bin;\n  var obj = {};\n  var offset0 = offset;\n  var tableVersion = bin.readFixed(data, offset);\n  offset += 4;\n  var offScriptList = bin.readUshort(data, offset);\n  offset += 2;\n  var offFeatureList = bin.readUshort(data, offset);\n  offset += 2;\n  var offLookupList = bin.readUshort(data, offset);\n  offset += 2;\n  obj.scriptList = Typr._lctf.readScriptList(data, offset0 + offScriptList);\n  obj.featureList = Typr._lctf.readFeatureList(data, offset0 + offFeatureList);\n  obj.lookupList = Typr._lctf.readLookupList(data, offset0 + offLookupList, subt);\n  return obj;\n};\n\nTypr._lctf.readLookupList = function (data, offset, subt) {\n  var bin = Typr._bin;\n  var offset0 = offset;\n  var obj = [];\n  var count = bin.readUshort(data, offset);\n  offset += 2;\n\n  for (var i = 0; i < count; i++) {\n    var noff = bin.readUshort(data, offset);\n    offset += 2;\n\n    var lut = Typr._lctf.readLookupTable(data, offset0 + noff, subt);\n\n    obj.push(lut);\n  }\n\n  return obj;\n};\n\nTypr._lctf.readLookupTable = function (data, offset, subt) {\n  var bin = Typr._bin;\n  var offset0 = offset;\n  var obj = {\n    tabs: []\n  };\n  obj.ltype = bin.readUshort(data, offset);\n  offset += 2;\n  obj.flag = bin.readUshort(data, offset);\n  offset += 2;\n  var cnt = bin.readUshort(data, offset);\n  offset += 2;\n\n  for (var i = 0; i < cnt; i++) {\n    var noff = bin.readUshort(data, offset);\n    offset += 2;\n    var tab = subt(data, obj.ltype, offset0 + noff);\n    obj.tabs.push(tab);\n  }\n\n  return obj;\n};\n\nTypr._lctf.numOfOnes = function (n) {\n  var num = 0;\n\n  for (var i = 0; i < 32; i++) {\n    if ((n >>> i & 1) != 0) {\n      num++;\n    }\n  }\n\n  return num;\n};\n\nTypr._lctf.readClassDef = function (data, offset) {\n  var bin = Typr._bin;\n  var obj = [];\n  var format = bin.readUshort(data, offset);\n  offset += 2;\n\n  if (format == 1) {\n    var startGlyph = bin.readUshort(data, offset);\n    offset += 2;\n    var glyphCount = bin.readUshort(data, offset);\n    offset += 2;\n\n    for (var i = 0; i < glyphCount; i++) {\n      obj.push(startGlyph + i);\n      obj.push(startGlyph + i);\n      obj.push(bin.readUshort(data, offset));\n      offset += 2;\n    }\n  }\n\n  if (format == 2) {\n    var count = bin.readUshort(data, offset);\n    offset += 2;\n\n    for (var i = 0; i < count; i++) {\n      obj.push(bin.readUshort(data, offset));\n      offset += 2;\n      obj.push(bin.readUshort(data, offset));\n      offset += 2;\n      obj.push(bin.readUshort(data, offset));\n      offset += 2;\n    }\n  }\n\n  return obj;\n};\n\nTypr._lctf.getInterval = function (tab, val) {\n  for (var i = 0; i < tab.length; i += 3) {\n    var start = tab[i],\n        end = tab[i + 1],\n        index = tab[i + 2];\n\n    if (start <= val && val <= end) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\nTypr._lctf.readValueRecord = function (data, offset, valFmt) {\n  var bin = Typr._bin;\n  var arr = [];\n  arr.push(valFmt & 1 ? bin.readShort(data, offset) : 0);\n  offset += valFmt & 1 ? 2 : 0;\n  arr.push(valFmt & 2 ? bin.readShort(data, offset) : 0);\n  offset += valFmt & 2 ? 2 : 0;\n  arr.push(valFmt & 4 ? bin.readShort(data, offset) : 0);\n  offset += valFmt & 4 ? 2 : 0;\n  arr.push(valFmt & 8 ? bin.readShort(data, offset) : 0);\n  offset += valFmt & 8 ? 2 : 0;\n  return arr;\n};\n\nTypr._lctf.readCoverage = function (data, offset) {\n  var bin = Typr._bin;\n  var cvg = {};\n  cvg.fmt = bin.readUshort(data, offset);\n  offset += 2;\n  var count = bin.readUshort(data, offset);\n  offset += 2;\n\n  if (cvg.fmt == 1) {\n    cvg.tab = bin.readUshorts(data, offset, count);\n  }\n\n  if (cvg.fmt == 2) {\n    cvg.tab = bin.readUshorts(data, offset, count * 3);\n  }\n\n  return cvg;\n};\n\nTypr._lctf.coverageIndex = function (cvg, val) {\n  var tab = cvg.tab;\n\n  if (cvg.fmt == 1) {\n    return tab.indexOf(val);\n  }\n\n  if (cvg.fmt == 2) {\n    var ind = Typr._lctf.getInterval(tab, val);\n\n    if (ind != -1) {\n      return tab[ind + 2] + (val - tab[ind]);\n    }\n  }\n\n  return -1;\n};\n\nTypr._lctf.readFeatureList = function (data, offset) {\n  var bin = Typr._bin;\n  var offset0 = offset;\n  var obj = [];\n  var count = bin.readUshort(data, offset);\n  offset += 2;\n\n  for (var i = 0; i < count; i++) {\n    var tag = bin.readASCII(data, offset, 4);\n    offset += 4;\n    var noff = bin.readUshort(data, offset);\n    offset += 2;\n    obj.push({\n      tag: tag.trim(),\n      tab: Typr._lctf.readFeatureTable(data, offset0 + noff)\n    });\n  }\n\n  return obj;\n};\n\nTypr._lctf.readFeatureTable = function (data, offset) {\n  var bin = Typr._bin;\n  var featureParams = bin.readUshort(data, offset);\n  offset += 2;\n  var lookupCount = bin.readUshort(data, offset);\n  offset += 2;\n  var indices = [];\n\n  for (var i = 0; i < lookupCount; i++) {\n    indices.push(bin.readUshort(data, offset + 2 * i));\n  }\n\n  return indices;\n};\n\nTypr._lctf.readScriptList = function (data, offset) {\n  var bin = Typr._bin;\n  var offset0 = offset;\n  var obj = {};\n  var count = bin.readUshort(data, offset);\n  offset += 2;\n\n  for (var i = 0; i < count; i++) {\n    var tag = bin.readASCII(data, offset, 4);\n    offset += 4;\n    var noff = bin.readUshort(data, offset);\n    offset += 2;\n    obj[tag.trim()] = Typr._lctf.readScriptTable(data, offset0 + noff);\n  }\n\n  return obj;\n};\n\nTypr._lctf.readScriptTable = function (data, offset) {\n  var bin = Typr._bin;\n  var offset0 = offset;\n  var obj = {};\n  var defLangSysOff = bin.readUshort(data, offset);\n  offset += 2;\n  obj.default = Typr._lctf.readLangSysTable(data, offset0 + defLangSysOff);\n  var langSysCount = bin.readUshort(data, offset);\n  offset += 2;\n\n  for (var i = 0; i < langSysCount; i++) {\n    var tag = bin.readASCII(data, offset, 4);\n    offset += 4;\n    var langSysOff = bin.readUshort(data, offset);\n    offset += 2;\n    obj[tag.trim()] = Typr._lctf.readLangSysTable(data, offset0 + langSysOff);\n  }\n\n  return obj;\n};\n\nTypr._lctf.readLangSysTable = function (data, offset) {\n  var bin = Typr._bin;\n  var obj = {};\n  var lookupOrder = bin.readUshort(data, offset);\n  offset += 2;\n  obj.reqFeature = bin.readUshort(data, offset);\n  offset += 2;\n  var featureCount = bin.readUshort(data, offset);\n  offset += 2;\n  obj.features = bin.readUshorts(data, offset, featureCount);\n  return obj;\n};\n\nTypr.CFF = {};\n\nTypr.CFF.parse = function (data, offset, length) {\n  var bin = Typr._bin;\n  data = new Uint8Array(data.buffer, offset, length);\n  offset = 0;\n  var major = data[offset];\n  offset++;\n  var minor = data[offset];\n  offset++;\n  var hdrSize = data[offset];\n  offset++;\n  var offsize = data[offset];\n  offset++;\n  var ninds = [];\n  offset = Typr.CFF.readIndex(data, offset, ninds);\n  var names = [];\n\n  for (var i = 0; i < ninds.length - 1; i++) {\n    names.push(bin.readASCII(data, offset + ninds[i], ninds[i + 1] - ninds[i]));\n  }\n\n  offset += ninds[ninds.length - 1];\n  var tdinds = [];\n  offset = Typr.CFF.readIndex(data, offset, tdinds);\n  var topDicts = [];\n\n  for (var i = 0; i < tdinds.length - 1; i++) {\n    topDicts.push(Typr.CFF.readDict(data, offset + tdinds[i], offset + tdinds[i + 1]));\n  }\n\n  offset += tdinds[tdinds.length - 1];\n  var topdict = topDicts[0];\n  var sinds = [];\n  offset = Typr.CFF.readIndex(data, offset, sinds);\n  var strings = [];\n\n  for (var i = 0; i < sinds.length - 1; i++) {\n    strings.push(bin.readASCII(data, offset + sinds[i], sinds[i + 1] - sinds[i]));\n  }\n\n  offset += sinds[sinds.length - 1];\n  Typr.CFF.readSubrs(data, offset, topdict);\n\n  if (topdict.CharStrings) {\n    offset = topdict.CharStrings;\n    var sinds = [];\n    offset = Typr.CFF.readIndex(data, offset, sinds);\n    var cstr = [];\n\n    for (var i = 0; i < sinds.length - 1; i++) {\n      cstr.push(bin.readBytes(data, offset + sinds[i], sinds[i + 1] - sinds[i]));\n    }\n\n    topdict.CharStrings = cstr;\n  }\n\n  if (topdict.Encoding) {\n    topdict.Encoding = Typr.CFF.readEncoding(data, topdict.Encoding, topdict.CharStrings.length);\n  }\n\n  if (topdict.charset) {\n    topdict.charset = Typr.CFF.readCharset(data, topdict.charset, topdict.CharStrings.length);\n  }\n\n  if (topdict.Private) {\n    offset = topdict.Private[1];\n    topdict.Private = Typr.CFF.readDict(data, offset, offset + topdict.Private[0]);\n\n    if (topdict.Private.Subrs) {\n      Typr.CFF.readSubrs(data, offset + topdict.Private.Subrs, topdict.Private);\n    }\n  }\n\n  var obj = {};\n\n  for (var p in topdict) {\n    if ([\"FamilyName\", \"FullName\", \"Notice\", \"version\", \"Copyright\"].indexOf(p) != -1) {\n      obj[p] = strings[topdict[p] - 426 + 35];\n    } else {\n      obj[p] = topdict[p];\n    }\n  }\n\n  return obj;\n};\n\nTypr.CFF.readSubrs = function (data, offset, obj) {\n  var bin = Typr._bin;\n  var gsubinds = [];\n  offset = Typr.CFF.readIndex(data, offset, gsubinds);\n  var bias,\n      nSubrs = gsubinds.length;\n\n  if (nSubrs < 1240) {\n    bias = 107;\n  } else if (nSubrs < 33900) {\n    bias = 1131;\n  } else {\n    bias = 32768;\n  }\n\n  obj.Bias = bias;\n  obj.Subrs = [];\n\n  for (var i = 0; i < gsubinds.length - 1; i++) {\n    obj.Subrs.push(bin.readBytes(data, offset + gsubinds[i], gsubinds[i + 1] - gsubinds[i]));\n  }\n};\n\nTypr.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0];\n\nTypr.CFF.glyphByUnicode = function (cff, code) {\n  for (var i = 0; i < cff.charset.length; i++) {\n    if (cff.charset[i] == code) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\nTypr.CFF.glyphBySE = function (cff, charcode) {\n  if (charcode < 0 || charcode > 255) {\n    return -1;\n  }\n\n  return Typr.CFF.glyphByUnicode(cff, Typr.CFF.tableSE[charcode]);\n};\n\nTypr.CFF.readEncoding = function (data, offset, num) {\n  var bin = Typr._bin;\n  var array = [\".notdef\"];\n  var format = data[offset];\n  offset++;\n\n  if (format == 0) {\n    var nCodes = data[offset];\n    offset++;\n\n    for (var i = 0; i < nCodes; i++) {\n      array.push(data[offset + i]);\n    }\n  } else {\n    throw \"error: unknown encoding format: \" + format;\n  }\n\n  return array;\n};\n\nTypr.CFF.readCharset = function (data, offset, num) {\n  var bin = Typr._bin;\n  var charset = [\".notdef\"];\n  var format = data[offset];\n  offset++;\n\n  if (format == 0) {\n    for (var i = 0; i < num; i++) {\n      var first = bin.readUshort(data, offset);\n      offset += 2;\n      charset.push(first);\n    }\n  } else if (format == 1 || format == 2) {\n    while (charset.length < num) {\n      var first = bin.readUshort(data, offset);\n      offset += 2;\n      var nLeft = 0;\n\n      if (format == 1) {\n        nLeft = data[offset];\n        offset++;\n      } else {\n        nLeft = bin.readUshort(data, offset);\n        offset += 2;\n      }\n\n      for (var i = 0; i <= nLeft; i++) {\n        charset.push(first);\n        first++;\n      }\n    }\n  } else {\n    throw \"error: format: \" + format;\n  }\n\n  return charset;\n};\n\nTypr.CFF.readIndex = function (data, offset, inds) {\n  var bin = Typr._bin;\n  var count = bin.readUshort(data, offset);\n  offset += 2;\n  var offsize = data[offset];\n  offset++;\n\n  if (offsize == 1) {\n    for (var i = 0; i < count + 1; i++) {\n      inds.push(data[offset + i]);\n    }\n  } else if (offsize == 2) {\n    for (var i = 0; i < count + 1; i++) {\n      inds.push(bin.readUshort(data, offset + i * 2));\n    }\n  } else if (offsize == 3) {\n    for (var i = 0; i < count + 1; i++) {\n      inds.push(bin.readUint(data, offset + i * 3 - 1) & 16777215);\n    }\n  } else if (count != 0) {\n    throw \"unsupported offset size: \" + offsize + \", count: \" + count;\n  }\n\n  offset += (count + 1) * offsize;\n  return offset - 1;\n};\n\nTypr.CFF.getCharString = function (data, offset, o) {\n  var bin = Typr._bin;\n  var b0 = data[offset],\n      b1 = data[offset + 1],\n      b2 = data[offset + 2],\n      b3 = data[offset + 3],\n      b4 = data[offset + 4];\n  var vs = 1;\n  var op = null,\n      val = null;\n\n  if (b0 <= 20) {\n    op = b0;\n    vs = 1;\n  }\n\n  if (b0 == 12) {\n    op = b0 * 100 + b1;\n    vs = 2;\n  }\n\n  if (21 <= b0 && b0 <= 27) {\n    op = b0;\n    vs = 1;\n  }\n\n  if (b0 == 28) {\n    val = bin.readShort(data, offset + 1);\n    vs = 3;\n  }\n\n  if (29 <= b0 && b0 <= 31) {\n    op = b0;\n    vs = 1;\n  }\n\n  if (32 <= b0 && b0 <= 246) {\n    val = b0 - 139;\n    vs = 1;\n  }\n\n  if (247 <= b0 && b0 <= 250) {\n    val = (b0 - 247) * 256 + b1 + 108;\n    vs = 2;\n  }\n\n  if (251 <= b0 && b0 <= 254) {\n    val = -(b0 - 251) * 256 - b1 - 108;\n    vs = 2;\n  }\n\n  if (b0 == 255) {\n    val = bin.readInt(data, offset + 1) / 65535;\n    vs = 5;\n  }\n\n  o.val = val != null ? val : \"o\" + op;\n  o.size = vs;\n};\n\nTypr.CFF.readCharString = function (data, offset, length) {\n  var end = offset + length;\n  var bin = Typr._bin;\n  var arr = [];\n\n  while (offset < end) {\n    var b0 = data[offset],\n        b1 = data[offset + 1],\n        b2 = data[offset + 2],\n        b3 = data[offset + 3],\n        b4 = data[offset + 4];\n    var vs = 1;\n    var op = null,\n        val = null;\n\n    if (b0 <= 20) {\n      op = b0;\n      vs = 1;\n    }\n\n    if (b0 == 12) {\n      op = b0 * 100 + b1;\n      vs = 2;\n    }\n\n    if (b0 == 19 || b0 == 20) {\n      op = b0;\n      vs = 2;\n    }\n\n    if (21 <= b0 && b0 <= 27) {\n      op = b0;\n      vs = 1;\n    }\n\n    if (b0 == 28) {\n      val = bin.readShort(data, offset + 1);\n      vs = 3;\n    }\n\n    if (29 <= b0 && b0 <= 31) {\n      op = b0;\n      vs = 1;\n    }\n\n    if (32 <= b0 && b0 <= 246) {\n      val = b0 - 139;\n      vs = 1;\n    }\n\n    if (247 <= b0 && b0 <= 250) {\n      val = (b0 - 247) * 256 + b1 + 108;\n      vs = 2;\n    }\n\n    if (251 <= b0 && b0 <= 254) {\n      val = -(b0 - 251) * 256 - b1 - 108;\n      vs = 2;\n    }\n\n    if (b0 == 255) {\n      val = bin.readInt(data, offset + 1) / 65535;\n      vs = 5;\n    }\n\n    arr.push(val != null ? val : \"o\" + op);\n    offset += vs;\n  }\n\n  return arr;\n};\n\nTypr.CFF.readDict = function (data, offset, end) {\n  var bin = Typr._bin;\n  var dict = {};\n  var carr = [];\n\n  while (offset < end) {\n    var b0 = data[offset],\n        b1 = data[offset + 1],\n        b2 = data[offset + 2],\n        b3 = data[offset + 3],\n        b4 = data[offset + 4];\n    var vs = 1;\n    var key = null,\n        val = null;\n\n    if (b0 == 28) {\n      val = bin.readShort(data, offset + 1);\n      vs = 3;\n    }\n\n    if (b0 == 29) {\n      val = bin.readInt(data, offset + 1);\n      vs = 5;\n    }\n\n    if (32 <= b0 && b0 <= 246) {\n      val = b0 - 139;\n      vs = 1;\n    }\n\n    if (247 <= b0 && b0 <= 250) {\n      val = (b0 - 247) * 256 + b1 + 108;\n      vs = 2;\n    }\n\n    if (251 <= b0 && b0 <= 254) {\n      val = -(b0 - 251) * 256 - b1 - 108;\n      vs = 2;\n    }\n\n    if (b0 == 255) {\n      val = bin.readInt(data, offset + 1) / 65535;\n      vs = 5;\n      throw \"unknown number\";\n    }\n\n    if (b0 == 30) {\n      var nibs = [];\n      vs = 1;\n\n      while (true) {\n        var b = data[offset + vs];\n        vs++;\n        var nib0 = b >> 4,\n            nib1 = b & 15;\n\n        if (nib0 != 15) {\n          nibs.push(nib0);\n        }\n\n        if (nib1 != 15) {\n          nibs.push(nib1);\n        }\n\n        if (nib1 == 15) {\n          break;\n        }\n      }\n\n      var s = \"\";\n      var chars = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, \".\", \"e\", \"e-\", \"reserved\", \"-\", \"endOfNumber\"];\n\n      for (var i = 0; i < nibs.length; i++) {\n        s += chars[nibs[i]];\n      }\n\n      val = parseFloat(s);\n    }\n\n    if (b0 <= 21) {\n      var keys = [\"version\", \"Notice\", \"FullName\", \"FamilyName\", \"Weight\", \"FontBBox\", \"BlueValues\", \"OtherBlues\", \"FamilyBlues\", \"FamilyOtherBlues\", \"StdHW\", \"StdVW\", \"escape\", \"UniqueID\", \"XUID\", \"charset\", \"Encoding\", \"CharStrings\", \"Private\", \"Subrs\", \"defaultWidthX\", \"nominalWidthX\"];\n      key = keys[b0];\n      vs = 1;\n\n      if (b0 == 12) {\n        var keys = [\"Copyright\", \"isFixedPitch\", \"ItalicAngle\", \"UnderlinePosition\", \"UnderlineThickness\", \"PaintType\", \"CharstringType\", \"FontMatrix\", \"StrokeWidth\", \"BlueScale\", \"BlueShift\", \"BlueFuzz\", \"StemSnapH\", \"StemSnapV\", \"ForceBold\", 0, 0, \"LanguageGroup\", \"ExpansionFactor\", \"initialRandomSeed\", \"SyntheticBase\", \"PostScript\", \"BaseFontName\", \"BaseFontBlend\", 0, 0, 0, 0, 0, 0, \"ROS\", \"CIDFontVersion\", \"CIDFontRevision\", \"CIDFontType\", \"CIDCount\", \"UIDBase\", \"FDArray\", \"FDSelect\", \"FontName\"];\n        key = keys[b1];\n        vs = 2;\n      }\n    }\n\n    if (key != null) {\n      dict[key] = carr.length == 1 ? carr[0] : carr;\n      carr = [];\n    } else {\n      carr.push(val);\n    }\n\n    offset += vs;\n  }\n\n  return dict;\n};\n\nTypr.cmap = {};\n\nTypr.cmap.parse = function (data, offset, length) {\n  data = new Uint8Array(data.buffer, offset, length);\n  offset = 0;\n  var bin = Typr._bin;\n  var obj = {};\n  var version = bin.readUshort(data, offset);\n  offset += 2;\n  var numTables = bin.readUshort(data, offset);\n  offset += 2;\n  var offs = [];\n  obj.tables = [];\n\n  for (var i = 0; i < numTables; i++) {\n    var platformID = bin.readUshort(data, offset);\n    offset += 2;\n    var encodingID = bin.readUshort(data, offset);\n    offset += 2;\n    var noffset = bin.readUint(data, offset);\n    offset += 4;\n    var id = \"p\" + platformID + \"e\" + encodingID;\n    var tind = offs.indexOf(noffset);\n\n    if (tind == -1) {\n      tind = obj.tables.length;\n      var subt;\n      offs.push(noffset);\n      var format = bin.readUshort(data, noffset);\n\n      if (format == 0) {\n        subt = Typr.cmap.parse0(data, noffset);\n      } else if (format == 4) {\n        subt = Typr.cmap.parse4(data, noffset);\n      } else if (format == 6) {\n        subt = Typr.cmap.parse6(data, noffset);\n      } else if (format == 12) {\n        subt = Typr.cmap.parse12(data, noffset);\n      } else {\n        console.log(\"unknown format: \" + format, platformID, encodingID, noffset);\n      }\n\n      obj.tables.push(subt);\n    }\n\n    if (obj[id] != null) {\n      throw \"multiple tables for one platform+encoding\";\n    }\n\n    obj[id] = tind;\n  }\n\n  return obj;\n};\n\nTypr.cmap.parse0 = function (data, offset) {\n  var bin = Typr._bin;\n  var obj = {};\n  obj.format = bin.readUshort(data, offset);\n  offset += 2;\n  var len = bin.readUshort(data, offset);\n  offset += 2;\n  var lang = bin.readUshort(data, offset);\n  offset += 2;\n  obj.map = [];\n\n  for (var i = 0; i < len - 6; i++) {\n    obj.map.push(data[offset + i]);\n  }\n\n  return obj;\n};\n\nTypr.cmap.parse4 = function (data, offset) {\n  var bin = Typr._bin;\n  var offset0 = offset;\n  var obj = {};\n  obj.format = bin.readUshort(data, offset);\n  offset += 2;\n  var length = bin.readUshort(data, offset);\n  offset += 2;\n  var language = bin.readUshort(data, offset);\n  offset += 2;\n  var segCountX2 = bin.readUshort(data, offset);\n  offset += 2;\n  var segCount = segCountX2 / 2;\n  obj.searchRange = bin.readUshort(data, offset);\n  offset += 2;\n  obj.entrySelector = bin.readUshort(data, offset);\n  offset += 2;\n  obj.rangeShift = bin.readUshort(data, offset);\n  offset += 2;\n  obj.endCount = bin.readUshorts(data, offset, segCount);\n  offset += segCount * 2;\n  offset += 2;\n  obj.startCount = bin.readUshorts(data, offset, segCount);\n  offset += segCount * 2;\n  obj.idDelta = [];\n\n  for (var i = 0; i < segCount; i++) {\n    obj.idDelta.push(bin.readShort(data, offset));\n    offset += 2;\n  }\n\n  obj.idRangeOffset = bin.readUshorts(data, offset, segCount);\n  offset += segCount * 2;\n  obj.glyphIdArray = [];\n\n  while (offset < offset0 + length) {\n    obj.glyphIdArray.push(bin.readUshort(data, offset));\n    offset += 2;\n  }\n\n  return obj;\n};\n\nTypr.cmap.parse6 = function (data, offset) {\n  var bin = Typr._bin;\n  var obj = {};\n  obj.format = bin.readUshort(data, offset);\n  offset += 2;\n  var length = bin.readUshort(data, offset);\n  offset += 2;\n  var language = bin.readUshort(data, offset);\n  offset += 2;\n  obj.firstCode = bin.readUshort(data, offset);\n  offset += 2;\n  var entryCount = bin.readUshort(data, offset);\n  offset += 2;\n  obj.glyphIdArray = [];\n\n  for (var i = 0; i < entryCount; i++) {\n    obj.glyphIdArray.push(bin.readUshort(data, offset));\n    offset += 2;\n  }\n\n  return obj;\n};\n\nTypr.cmap.parse12 = function (data, offset) {\n  var bin = Typr._bin;\n  var obj = {};\n  obj.format = bin.readUshort(data, offset);\n  offset += 2;\n  offset += 2;\n  var length = bin.readUint(data, offset);\n  offset += 4;\n  var lang = bin.readUint(data, offset);\n  offset += 4;\n  var nGroups = bin.readUint(data, offset);\n  offset += 4;\n  obj.groups = [];\n\n  for (var i = 0; i < nGroups; i++) {\n    var off = offset + i * 12;\n    var startCharCode = bin.readUint(data, off + 0);\n    var endCharCode = bin.readUint(data, off + 4);\n    var startGlyphID = bin.readUint(data, off + 8);\n    obj.groups.push([startCharCode, endCharCode, startGlyphID]);\n  }\n\n  return obj;\n};\n\nTypr.glyf = {};\n\nTypr.glyf.parse = function (data, offset, length, font) {\n  var obj = [];\n\n  for (var g = 0; g < font.maxp.numGlyphs; g++) {\n    obj.push(null);\n  }\n\n  return obj;\n};\n\nTypr.glyf._parseGlyf = function (font, g) {\n  var bin = Typr._bin;\n  var data = font._data;\n  var offset = Typr._tabOffset(data, \"glyf\") + font.loca[g];\n\n  if (font.loca[g] == font.loca[g + 1]) {\n    return null;\n  }\n\n  var gl = {};\n  gl.noc = bin.readShort(data, offset);\n  offset += 2;\n  gl.xMin = bin.readShort(data, offset);\n  offset += 2;\n  gl.yMin = bin.readShort(data, offset);\n  offset += 2;\n  gl.xMax = bin.readShort(data, offset);\n  offset += 2;\n  gl.yMax = bin.readShort(data, offset);\n  offset += 2;\n\n  if (gl.xMin >= gl.xMax || gl.yMin >= gl.yMax) {\n    return null;\n  }\n\n  if (gl.noc > 0) {\n    gl.endPts = [];\n\n    for (var i = 0; i < gl.noc; i++) {\n      gl.endPts.push(bin.readUshort(data, offset));\n      offset += 2;\n    }\n\n    var instructionLength = bin.readUshort(data, offset);\n    offset += 2;\n\n    if (data.length - offset < instructionLength) {\n      return null;\n    }\n\n    gl.instructions = bin.readBytes(data, offset, instructionLength);\n    offset += instructionLength;\n    var crdnum = gl.endPts[gl.noc - 1] + 1;\n    gl.flags = [];\n\n    for (var i = 0; i < crdnum; i++) {\n      var flag = data[offset];\n      offset++;\n      gl.flags.push(flag);\n\n      if ((flag & 8) != 0) {\n        var rep = data[offset];\n        offset++;\n\n        for (var j = 0; j < rep; j++) {\n          gl.flags.push(flag);\n          i++;\n        }\n      }\n    }\n\n    gl.xs = [];\n\n    for (var i = 0; i < crdnum; i++) {\n      var i8 = (gl.flags[i] & 2) != 0,\n          same = (gl.flags[i] & 16) != 0;\n\n      if (i8) {\n        gl.xs.push(same ? data[offset] : -data[offset]);\n        offset++;\n      } else {\n        if (same) {\n          gl.xs.push(0);\n        } else {\n          gl.xs.push(bin.readShort(data, offset));\n          offset += 2;\n        }\n      }\n    }\n\n    gl.ys = [];\n\n    for (var i = 0; i < crdnum; i++) {\n      var i8 = (gl.flags[i] & 4) != 0,\n          same = (gl.flags[i] & 32) != 0;\n\n      if (i8) {\n        gl.ys.push(same ? data[offset] : -data[offset]);\n        offset++;\n      } else {\n        if (same) {\n          gl.ys.push(0);\n        } else {\n          gl.ys.push(bin.readShort(data, offset));\n          offset += 2;\n        }\n      }\n    }\n\n    var x = 0,\n        y = 0;\n\n    for (var i = 0; i < crdnum; i++) {\n      x += gl.xs[i];\n      y += gl.ys[i];\n      gl.xs[i] = x;\n      gl.ys[i] = y;\n    }\n  } else {\n    var ARG_1_AND_2_ARE_WORDS = 1 << 0;\n    var ARGS_ARE_XY_VALUES = 1 << 1;\n    var WE_HAVE_A_SCALE = 1 << 3;\n    var MORE_COMPONENTS = 1 << 5;\n    var WE_HAVE_AN_X_AND_Y_SCALE = 1 << 6;\n    var WE_HAVE_A_TWO_BY_TWO = 1 << 7;\n    var WE_HAVE_INSTRUCTIONS = 1 << 8;\n    gl.parts = [];\n    var flags;\n\n    do {\n      flags = bin.readUshort(data, offset);\n      offset += 2;\n      var part = {\n        m: {\n          a: 1,\n          b: 0,\n          c: 0,\n          d: 1,\n          tx: 0,\n          ty: 0\n        },\n        p1: -1,\n        p2: -1\n      };\n      gl.parts.push(part);\n      part.glyphIndex = bin.readUshort(data, offset);\n      offset += 2;\n\n      if (flags & ARG_1_AND_2_ARE_WORDS) {\n        var arg1 = bin.readShort(data, offset);\n        offset += 2;\n        var arg2 = bin.readShort(data, offset);\n        offset += 2;\n      } else {\n        var arg1 = bin.readInt8(data, offset);\n        offset++;\n        var arg2 = bin.readInt8(data, offset);\n        offset++;\n      }\n\n      if (flags & ARGS_ARE_XY_VALUES) {\n        part.m.tx = arg1;\n        part.m.ty = arg2;\n      } else {\n        part.p1 = arg1;\n        part.p2 = arg2;\n      }\n\n      if (flags & WE_HAVE_A_SCALE) {\n        part.m.a = part.m.d = bin.readF2dot14(data, offset);\n        offset += 2;\n      } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {\n        part.m.a = bin.readF2dot14(data, offset);\n        offset += 2;\n        part.m.d = bin.readF2dot14(data, offset);\n        offset += 2;\n      } else if (flags & WE_HAVE_A_TWO_BY_TWO) {\n        part.m.a = bin.readF2dot14(data, offset);\n        offset += 2;\n        part.m.b = bin.readF2dot14(data, offset);\n        offset += 2;\n        part.m.c = bin.readF2dot14(data, offset);\n        offset += 2;\n        part.m.d = bin.readF2dot14(data, offset);\n        offset += 2;\n      }\n    } while (flags & MORE_COMPONENTS);\n\n    if (flags & WE_HAVE_INSTRUCTIONS) {\n      var numInstr = bin.readUshort(data, offset);\n      offset += 2;\n      gl.instr = [];\n\n      for (var i = 0; i < numInstr; i++) {\n        gl.instr.push(data[offset]);\n        offset++;\n      }\n    }\n  }\n\n  return gl;\n};\n\nTypr.GPOS = {};\n\nTypr.GPOS.parse = function (data, offset, length, font) {\n  return Typr._lctf.parse(data, offset, length, font, Typr.GPOS.subt);\n};\n\nTypr.GPOS.subt = function (data, ltype, offset) {\n  if (ltype != 2) {\n    return null;\n  }\n\n  var bin = Typr._bin,\n      offset0 = offset,\n      tab = {};\n  tab.format = bin.readUshort(data, offset);\n  offset += 2;\n  var covOff = bin.readUshort(data, offset);\n  offset += 2;\n  tab.coverage = Typr._lctf.readCoverage(data, covOff + offset0);\n  tab.valFmt1 = bin.readUshort(data, offset);\n  offset += 2;\n  tab.valFmt2 = bin.readUshort(data, offset);\n  offset += 2;\n\n  var ones1 = Typr._lctf.numOfOnes(tab.valFmt1);\n\n  var ones2 = Typr._lctf.numOfOnes(tab.valFmt2);\n\n  if (tab.format == 1) {\n    tab.pairsets = [];\n    var count = bin.readUshort(data, offset);\n    offset += 2;\n\n    for (var i = 0; i < count; i++) {\n      var psoff = bin.readUshort(data, offset);\n      offset += 2;\n      psoff += offset0;\n      var pvcount = bin.readUshort(data, psoff);\n      psoff += 2;\n      var arr = [];\n\n      for (var j = 0; j < pvcount; j++) {\n        var gid2 = bin.readUshort(data, psoff);\n        psoff += 2;\n        var value1, value2;\n\n        if (tab.valFmt1 != 0) {\n          value1 = Typr._lctf.readValueRecord(data, psoff, tab.valFmt1);\n          psoff += ones1 * 2;\n        }\n\n        if (tab.valFmt2 != 0) {\n          value2 = Typr._lctf.readValueRecord(data, psoff, tab.valFmt2);\n          psoff += ones2 * 2;\n        }\n\n        arr.push({\n          gid2: gid2,\n          val1: value1,\n          val2: value2\n        });\n      }\n\n      tab.pairsets.push(arr);\n    }\n  }\n\n  if (tab.format == 2) {\n    var classDef1 = bin.readUshort(data, offset);\n    offset += 2;\n    var classDef2 = bin.readUshort(data, offset);\n    offset += 2;\n    var class1Count = bin.readUshort(data, offset);\n    offset += 2;\n    var class2Count = bin.readUshort(data, offset);\n    offset += 2;\n    tab.classDef1 = Typr._lctf.readClassDef(data, offset0 + classDef1);\n    tab.classDef2 = Typr._lctf.readClassDef(data, offset0 + classDef2);\n    tab.matrix = [];\n\n    for (var i = 0; i < class1Count; i++) {\n      var row = [];\n\n      for (var j = 0; j < class2Count; j++) {\n        var value1 = null,\n            value2 = null;\n\n        if (tab.valFmt1 != 0) {\n          value1 = Typr._lctf.readValueRecord(data, offset, tab.valFmt1);\n          offset += ones1 * 2;\n        }\n\n        if (tab.valFmt2 != 0) {\n          value2 = Typr._lctf.readValueRecord(data, offset, tab.valFmt2);\n          offset += ones2 * 2;\n        }\n\n        row.push({\n          val1: value1,\n          val2: value2\n        });\n      }\n\n      tab.matrix.push(row);\n    }\n  }\n\n  return tab;\n};\n\nTypr.GSUB = {};\n\nTypr.GSUB.parse = function (data, offset, length, font) {\n  return Typr._lctf.parse(data, offset, length, font, Typr.GSUB.subt);\n};\n\nTypr.GSUB.subt = function (data, ltype, offset) {\n  var bin = Typr._bin,\n      offset0 = offset,\n      tab = {};\n\n  if (ltype != 1 && ltype != 4 && ltype != 5) {\n    return null;\n  }\n\n  tab.fmt = bin.readUshort(data, offset);\n  offset += 2;\n  var covOff = bin.readUshort(data, offset);\n  offset += 2;\n  tab.coverage = Typr._lctf.readCoverage(data, covOff + offset0);\n\n  if (ltype == 1) {\n    if (tab.fmt == 1) {\n      tab.delta = bin.readShort(data, offset);\n      offset += 2;\n    } else if (tab.fmt == 2) {\n      var cnt = bin.readUshort(data, offset);\n      offset += 2;\n      tab.newg = bin.readUshorts(data, offset, cnt);\n      offset += tab.newg.length * 2;\n    }\n  } else if (ltype == 4) {\n    tab.vals = [];\n    var cnt = bin.readUshort(data, offset);\n    offset += 2;\n\n    for (var i = 0; i < cnt; i++) {\n      var loff = bin.readUshort(data, offset);\n      offset += 2;\n      tab.vals.push(Typr.GSUB.readLigatureSet(data, offset0 + loff));\n    }\n  } else if (ltype == 5) {\n    if (tab.fmt == 2) {\n      var cDefOffset = bin.readUshort(data, offset);\n      offset += 2;\n      tab.cDef = Typr._lctf.readClassDef(data, offset0 + cDefOffset);\n      tab.scset = [];\n      var subClassSetCount = bin.readUshort(data, offset);\n      offset += 2;\n\n      for (var i = 0; i < subClassSetCount; i++) {\n        var scsOff = bin.readUshort(data, offset);\n        offset += 2;\n        tab.scset.push(scsOff == 0 ? null : Typr.GSUB.readSubClassSet(data, offset0 + scsOff));\n      }\n    } else {\n      console.log(\"unknown table format\", tab.fmt);\n    }\n  }\n\n  return tab;\n};\n\nTypr.GSUB.readSubClassSet = function (data, offset) {\n  var rUs = Typr._bin.readUshort,\n      offset0 = offset,\n      lset = [];\n  var cnt = rUs(data, offset);\n  offset += 2;\n\n  for (var i = 0; i < cnt; i++) {\n    var loff = rUs(data, offset);\n    offset += 2;\n    lset.push(Typr.GSUB.readSubClassRule(data, offset0 + loff));\n  }\n\n  return lset;\n};\n\nTypr.GSUB.readSubClassRule = function (data, offset) {\n  var rUs = Typr._bin.readUshort,\n      rule = {};\n  var gcount = rUs(data, offset);\n  offset += 2;\n  var scount = rUs(data, offset);\n  offset += 2;\n  rule.input = [];\n\n  for (var i = 0; i < gcount - 1; i++) {\n    rule.input.push(rUs(data, offset));\n    offset += 2;\n  }\n\n  rule.substLookupRecords = Typr.GSUB.readSubstLookupRecords(data, offset, scount);\n  return rule;\n};\n\nTypr.GSUB.readSubstLookupRecords = function (data, offset, cnt) {\n  var rUs = Typr._bin.readUshort;\n  var out = [];\n\n  for (var i = 0; i < cnt; i++) {\n    out.push(rUs(data, offset), rUs(data, offset + 2));\n    offset += 4;\n  }\n\n  return out;\n};\n\nTypr.GSUB.readChainSubClassSet = function (data, offset) {\n  var bin = Typr._bin,\n      offset0 = offset,\n      lset = [];\n  var cnt = bin.readUshort(data, offset);\n  offset += 2;\n\n  for (var i = 0; i < cnt; i++) {\n    var loff = bin.readUshort(data, offset);\n    offset += 2;\n    lset.push(Typr.GSUB.readChainSubClassRule(data, offset0 + loff));\n  }\n\n  return lset;\n};\n\nTypr.GSUB.readChainSubClassRule = function (data, offset) {\n  var bin = Typr._bin,\n      rule = {};\n  var pps = [\"backtrack\", \"input\", \"lookahead\"];\n\n  for (var pi = 0; pi < pps.length; pi++) {\n    var cnt = bin.readUshort(data, offset);\n    offset += 2;\n\n    if (pi == 1) {\n      cnt--;\n    }\n\n    rule[pps[pi]] = bin.readUshorts(data, offset, cnt);\n    offset += rule[pps[pi]].length * 2;\n  }\n\n  var cnt = bin.readUshort(data, offset);\n  offset += 2;\n  rule.subst = bin.readUshorts(data, offset, cnt * 2);\n  offset += rule.subst.length * 2;\n  return rule;\n};\n\nTypr.GSUB.readLigatureSet = function (data, offset) {\n  var bin = Typr._bin,\n      offset0 = offset,\n      lset = [];\n  var lcnt = bin.readUshort(data, offset);\n  offset += 2;\n\n  for (var j = 0; j < lcnt; j++) {\n    var loff = bin.readUshort(data, offset);\n    offset += 2;\n    lset.push(Typr.GSUB.readLigature(data, offset0 + loff));\n  }\n\n  return lset;\n};\n\nTypr.GSUB.readLigature = function (data, offset) {\n  var bin = Typr._bin,\n      lig = {\n    chain: []\n  };\n  lig.nglyph = bin.readUshort(data, offset);\n  offset += 2;\n  var ccnt = bin.readUshort(data, offset);\n  offset += 2;\n\n  for (var k = 0; k < ccnt - 1; k++) {\n    lig.chain.push(bin.readUshort(data, offset));\n    offset += 2;\n  }\n\n  return lig;\n};\n\nTypr.head = {};\n\nTypr.head.parse = function (data, offset, length) {\n  var bin = Typr._bin;\n  var obj = {};\n  var tableVersion = bin.readFixed(data, offset);\n  offset += 4;\n  obj.fontRevision = bin.readFixed(data, offset);\n  offset += 4;\n  var checkSumAdjustment = bin.readUint(data, offset);\n  offset += 4;\n  var magicNumber = bin.readUint(data, offset);\n  offset += 4;\n  obj.flags = bin.readUshort(data, offset);\n  offset += 2;\n  obj.unitsPerEm = bin.readUshort(data, offset);\n  offset += 2;\n  obj.created = bin.readUint64(data, offset);\n  offset += 8;\n  obj.modified = bin.readUint64(data, offset);\n  offset += 8;\n  obj.xMin = bin.readShort(data, offset);\n  offset += 2;\n  obj.yMin = bin.readShort(data, offset);\n  offset += 2;\n  obj.xMax = bin.readShort(data, offset);\n  offset += 2;\n  obj.yMax = bin.readShort(data, offset);\n  offset += 2;\n  obj.macStyle = bin.readUshort(data, offset);\n  offset += 2;\n  obj.lowestRecPPEM = bin.readUshort(data, offset);\n  offset += 2;\n  obj.fontDirectionHint = bin.readShort(data, offset);\n  offset += 2;\n  obj.indexToLocFormat = bin.readShort(data, offset);\n  offset += 2;\n  obj.glyphDataFormat = bin.readShort(data, offset);\n  offset += 2;\n  return obj;\n};\n\nTypr.hhea = {};\n\nTypr.hhea.parse = function (data, offset, length) {\n  var bin = Typr._bin;\n  var obj = {};\n  var tableVersion = bin.readFixed(data, offset);\n  offset += 4;\n  obj.ascender = bin.readShort(data, offset);\n  offset += 2;\n  obj.descender = bin.readShort(data, offset);\n  offset += 2;\n  obj.lineGap = bin.readShort(data, offset);\n  offset += 2;\n  obj.advanceWidthMax = bin.readUshort(data, offset);\n  offset += 2;\n  obj.minLeftSideBearing = bin.readShort(data, offset);\n  offset += 2;\n  obj.minRightSideBearing = bin.readShort(data, offset);\n  offset += 2;\n  obj.xMaxExtent = bin.readShort(data, offset);\n  offset += 2;\n  obj.caretSlopeRise = bin.readShort(data, offset);\n  offset += 2;\n  obj.caretSlopeRun = bin.readShort(data, offset);\n  offset += 2;\n  obj.caretOffset = bin.readShort(data, offset);\n  offset += 2;\n  offset += 4 * 2;\n  obj.metricDataFormat = bin.readShort(data, offset);\n  offset += 2;\n  obj.numberOfHMetrics = bin.readUshort(data, offset);\n  offset += 2;\n  return obj;\n};\n\nTypr.hmtx = {};\n\nTypr.hmtx.parse = function (data, offset, length, font) {\n  var bin = Typr._bin;\n  var obj = {};\n  obj.aWidth = [];\n  obj.lsBearing = [];\n  var aw = 0,\n      lsb = 0;\n\n  for (var i = 0; i < font.maxp.numGlyphs; i++) {\n    if (i < font.hhea.numberOfHMetrics) {\n      aw = bin.readUshort(data, offset);\n      offset += 2;\n      lsb = bin.readShort(data, offset);\n      offset += 2;\n    }\n\n    obj.aWidth.push(aw);\n    obj.lsBearing.push(lsb);\n  }\n\n  return obj;\n};\n\nTypr.kern = {};\n\nTypr.kern.parse = function (data, offset, length, font) {\n  var bin = Typr._bin;\n  var version = bin.readUshort(data, offset);\n  offset += 2;\n\n  if (version == 1) {\n    return Typr.kern.parseV1(data, offset - 2, length, font);\n  }\n\n  var nTables = bin.readUshort(data, offset);\n  offset += 2;\n  var map = {\n    glyph1: [],\n    rval: []\n  };\n\n  for (var i = 0; i < nTables; i++) {\n    offset += 2;\n    var length = bin.readUshort(data, offset);\n    offset += 2;\n    var coverage = bin.readUshort(data, offset);\n    offset += 2;\n    var format = coverage >>> 8;\n    format &= 15;\n\n    if (format == 0) {\n      offset = Typr.kern.readFormat0(data, offset, map);\n    } else {\n      throw \"unknown kern table format: \" + format;\n    }\n  }\n\n  return map;\n};\n\nTypr.kern.parseV1 = function (data, offset, length, font) {\n  var bin = Typr._bin;\n  var version = bin.readFixed(data, offset);\n  offset += 4;\n  var nTables = bin.readUint(data, offset);\n  offset += 4;\n  var map = {\n    glyph1: [],\n    rval: []\n  };\n\n  for (var i = 0; i < nTables; i++) {\n    var length = bin.readUint(data, offset);\n    offset += 4;\n    var coverage = bin.readUshort(data, offset);\n    offset += 2;\n    var tupleIndex = bin.readUshort(data, offset);\n    offset += 2;\n    var format = coverage >>> 8;\n    format &= 15;\n\n    if (format == 0) {\n      offset = Typr.kern.readFormat0(data, offset, map);\n    } else {\n      throw \"unknown kern table format: \" + format;\n    }\n  }\n\n  return map;\n};\n\nTypr.kern.readFormat0 = function (data, offset, map) {\n  var bin = Typr._bin;\n  var pleft = -1;\n  var nPairs = bin.readUshort(data, offset);\n  offset += 2;\n  var searchRange = bin.readUshort(data, offset);\n  offset += 2;\n  var entrySelector = bin.readUshort(data, offset);\n  offset += 2;\n  var rangeShift = bin.readUshort(data, offset);\n  offset += 2;\n\n  for (var j = 0; j < nPairs; j++) {\n    var left = bin.readUshort(data, offset);\n    offset += 2;\n    var right = bin.readUshort(data, offset);\n    offset += 2;\n    var value = bin.readShort(data, offset);\n    offset += 2;\n\n    if (left != pleft) {\n      map.glyph1.push(left);\n      map.rval.push({\n        glyph2: [],\n        vals: []\n      });\n    }\n\n    var rval = map.rval[map.rval.length - 1];\n    rval.glyph2.push(right);\n    rval.vals.push(value);\n    pleft = left;\n  }\n\n  return offset;\n};\n\nTypr.loca = {};\n\nTypr.loca.parse = function (data, offset, length, font) {\n  var bin = Typr._bin;\n  var obj = [];\n  var ver = font.head.indexToLocFormat;\n  var len = font.maxp.numGlyphs + 1;\n\n  if (ver == 0) {\n    for (var i = 0; i < len; i++) {\n      obj.push(bin.readUshort(data, offset + (i << 1)) << 1);\n    }\n  }\n\n  if (ver == 1) {\n    for (var i = 0; i < len; i++) {\n      obj.push(bin.readUint(data, offset + (i << 2)));\n    }\n  }\n\n  return obj;\n};\n\nTypr.maxp = {};\n\nTypr.maxp.parse = function (data, offset, length) {\n  var bin = Typr._bin;\n  var obj = {};\n  var ver = bin.readUint(data, offset);\n  offset += 4;\n  obj.numGlyphs = bin.readUshort(data, offset);\n  offset += 2;\n\n  if (ver == 65536) {\n    obj.maxPoints = bin.readUshort(data, offset);\n    offset += 2;\n    obj.maxContours = bin.readUshort(data, offset);\n    offset += 2;\n    obj.maxCompositePoints = bin.readUshort(data, offset);\n    offset += 2;\n    obj.maxCompositeContours = bin.readUshort(data, offset);\n    offset += 2;\n    obj.maxZones = bin.readUshort(data, offset);\n    offset += 2;\n    obj.maxTwilightPoints = bin.readUshort(data, offset);\n    offset += 2;\n    obj.maxStorage = bin.readUshort(data, offset);\n    offset += 2;\n    obj.maxFunctionDefs = bin.readUshort(data, offset);\n    offset += 2;\n    obj.maxInstructionDefs = bin.readUshort(data, offset);\n    offset += 2;\n    obj.maxStackElements = bin.readUshort(data, offset);\n    offset += 2;\n    obj.maxSizeOfInstructions = bin.readUshort(data, offset);\n    offset += 2;\n    obj.maxComponentElements = bin.readUshort(data, offset);\n    offset += 2;\n    obj.maxComponentDepth = bin.readUshort(data, offset);\n    offset += 2;\n  }\n\n  return obj;\n};\n\nTypr.name = {};\n\nTypr.name.parse = function (data, offset, length) {\n  var bin = Typr._bin;\n  var obj = {};\n  var format = bin.readUshort(data, offset);\n  offset += 2;\n  var count = bin.readUshort(data, offset);\n  offset += 2;\n  var stringOffset = bin.readUshort(data, offset);\n  offset += 2;\n  var offset0 = offset;\n\n  for (var i = 0; i < count; i++) {\n    var platformID = bin.readUshort(data, offset);\n    offset += 2;\n    var encodingID = bin.readUshort(data, offset);\n    offset += 2;\n    var languageID = bin.readUshort(data, offset);\n    offset += 2;\n    var nameID = bin.readUshort(data, offset);\n    offset += 2;\n    var length = bin.readUshort(data, offset);\n    offset += 2;\n    var noffset = bin.readUshort(data, offset);\n    offset += 2;\n    var plat = \"p\" + platformID;\n\n    if (obj[plat] == null) {\n      obj[plat] = {};\n    }\n\n    var names = [\"copyright\", \"fontFamily\", \"fontSubfamily\", \"ID\", \"fullName\", \"version\", \"postScriptName\", \"trademark\", \"manufacturer\", \"designer\", \"description\", \"urlVendor\", \"urlDesigner\", \"licence\", \"licenceURL\", \"---\", \"typoFamilyName\", \"typoSubfamilyName\", \"compatibleFull\", \"sampleText\", \"postScriptCID\", \"wwsFamilyName\", \"wwsSubfamilyName\", \"lightPalette\", \"darkPalette\"];\n    var cname = names[nameID];\n    var soff = offset0 + count * 12 + noffset;\n    var str;\n\n    if (platformID == 0) {\n      str = bin.readUnicode(data, soff, length / 2);\n    } else if (platformID == 3 && encodingID == 0) {\n      str = bin.readUnicode(data, soff, length / 2);\n    } else if (encodingID == 0) {\n      str = bin.readASCII(data, soff, length);\n    } else if (encodingID == 1) {\n      str = bin.readUnicode(data, soff, length / 2);\n    } else if (encodingID == 3) {\n      str = bin.readUnicode(data, soff, length / 2);\n    } else if (platformID == 1) {\n      str = bin.readASCII(data, soff, length);\n      console.log(\"reading unknown MAC encoding \" + encodingID + \" as ASCII\");\n    } else {\n      throw \"unknown encoding \" + encodingID + \", platformID: \" + platformID;\n    }\n\n    obj[plat][cname] = str;\n    obj[plat]._lang = languageID;\n  }\n\n  for (var p in obj) {\n    if (obj[p].postScriptName != null && obj[p]._lang == 1033) {\n      return obj[p];\n    }\n  }\n\n  for (var p in obj) {\n    if (obj[p].postScriptName != null && obj[p]._lang == 3084) {\n      return obj[p];\n    }\n  }\n\n  for (var p in obj) {\n    if (obj[p].postScriptName != null) {\n      return obj[p];\n    }\n  }\n\n  var tname;\n\n  for (var p in obj) {\n    tname = p;\n    break;\n  }\n\n  console.log(\"returning name table with languageID \" + obj[tname]._lang);\n  return obj[tname];\n};\n\nTypr[\"OS/2\"] = {};\n\nTypr[\"OS/2\"].parse = function (data, offset, length) {\n  var bin = Typr._bin;\n  var ver = bin.readUshort(data, offset);\n  offset += 2;\n  var obj = {};\n\n  if (ver == 0) {\n    Typr[\"OS/2\"].version0(data, offset, obj);\n  } else if (ver == 1) {\n    Typr[\"OS/2\"].version1(data, offset, obj);\n  } else if (ver == 2 || ver == 3 || ver == 4) {\n    Typr[\"OS/2\"].version2(data, offset, obj);\n  } else if (ver == 5) {\n    Typr[\"OS/2\"].version5(data, offset, obj);\n  } else {\n    throw \"unknown OS/2 table version: \" + ver;\n  }\n\n  return obj;\n};\n\nTypr[\"OS/2\"].version0 = function (data, offset, obj) {\n  var bin = Typr._bin;\n  obj.xAvgCharWidth = bin.readShort(data, offset);\n  offset += 2;\n  obj.usWeightClass = bin.readUshort(data, offset);\n  offset += 2;\n  obj.usWidthClass = bin.readUshort(data, offset);\n  offset += 2;\n  obj.fsType = bin.readUshort(data, offset);\n  offset += 2;\n  obj.ySubscriptXSize = bin.readShort(data, offset);\n  offset += 2;\n  obj.ySubscriptYSize = bin.readShort(data, offset);\n  offset += 2;\n  obj.ySubscriptXOffset = bin.readShort(data, offset);\n  offset += 2;\n  obj.ySubscriptYOffset = bin.readShort(data, offset);\n  offset += 2;\n  obj.ySuperscriptXSize = bin.readShort(data, offset);\n  offset += 2;\n  obj.ySuperscriptYSize = bin.readShort(data, offset);\n  offset += 2;\n  obj.ySuperscriptXOffset = bin.readShort(data, offset);\n  offset += 2;\n  obj.ySuperscriptYOffset = bin.readShort(data, offset);\n  offset += 2;\n  obj.yStrikeoutSize = bin.readShort(data, offset);\n  offset += 2;\n  obj.yStrikeoutPosition = bin.readShort(data, offset);\n  offset += 2;\n  obj.sFamilyClass = bin.readShort(data, offset);\n  offset += 2;\n  obj.panose = bin.readBytes(data, offset, 10);\n  offset += 10;\n  obj.ulUnicodeRange1 = bin.readUint(data, offset);\n  offset += 4;\n  obj.ulUnicodeRange2 = bin.readUint(data, offset);\n  offset += 4;\n  obj.ulUnicodeRange3 = bin.readUint(data, offset);\n  offset += 4;\n  obj.ulUnicodeRange4 = bin.readUint(data, offset);\n  offset += 4;\n  obj.achVendID = [bin.readInt8(data, offset), bin.readInt8(data, offset + 1), bin.readInt8(data, offset + 2), bin.readInt8(data, offset + 3)];\n  offset += 4;\n  obj.fsSelection = bin.readUshort(data, offset);\n  offset += 2;\n  obj.usFirstCharIndex = bin.readUshort(data, offset);\n  offset += 2;\n  obj.usLastCharIndex = bin.readUshort(data, offset);\n  offset += 2;\n  obj.sTypoAscender = bin.readShort(data, offset);\n  offset += 2;\n  obj.sTypoDescender = bin.readShort(data, offset);\n  offset += 2;\n  obj.sTypoLineGap = bin.readShort(data, offset);\n  offset += 2;\n  obj.usWinAscent = bin.readUshort(data, offset);\n  offset += 2;\n  obj.usWinDescent = bin.readUshort(data, offset);\n  offset += 2;\n  return offset;\n};\n\nTypr[\"OS/2\"].version1 = function (data, offset, obj) {\n  var bin = Typr._bin;\n  offset = Typr[\"OS/2\"].version0(data, offset, obj);\n  obj.ulCodePageRange1 = bin.readUint(data, offset);\n  offset += 4;\n  obj.ulCodePageRange2 = bin.readUint(data, offset);\n  offset += 4;\n  return offset;\n};\n\nTypr[\"OS/2\"].version2 = function (data, offset, obj) {\n  var bin = Typr._bin;\n  offset = Typr[\"OS/2\"].version1(data, offset, obj);\n  obj.sxHeight = bin.readShort(data, offset);\n  offset += 2;\n  obj.sCapHeight = bin.readShort(data, offset);\n  offset += 2;\n  obj.usDefault = bin.readUshort(data, offset);\n  offset += 2;\n  obj.usBreak = bin.readUshort(data, offset);\n  offset += 2;\n  obj.usMaxContext = bin.readUshort(data, offset);\n  offset += 2;\n  return offset;\n};\n\nTypr[\"OS/2\"].version5 = function (data, offset, obj) {\n  var bin = Typr._bin;\n  offset = Typr[\"OS/2\"].version2(data, offset, obj);\n  obj.usLowerOpticalPointSize = bin.readUshort(data, offset);\n  offset += 2;\n  obj.usUpperOpticalPointSize = bin.readUshort(data, offset);\n  offset += 2;\n  return offset;\n};\n\nTypr.post = {};\n\nTypr.post.parse = function (data, offset, length) {\n  var bin = Typr._bin;\n  var obj = {};\n  obj.version = bin.readFixed(data, offset);\n  offset += 4;\n  obj.italicAngle = bin.readFixed(data, offset);\n  offset += 4;\n  obj.underlinePosition = bin.readShort(data, offset);\n  offset += 2;\n  obj.underlineThickness = bin.readShort(data, offset);\n  offset += 2;\n  return obj;\n};\n\nTypr.SVG = {};\n\nTypr.SVG.parse = function (data, offset, length) {\n  var bin = Typr._bin;\n  var obj = {\n    entries: []\n  };\n  var offset0 = offset;\n  var tableVersion = bin.readUshort(data, offset);\n  offset += 2;\n  var svgDocIndexOffset = bin.readUint(data, offset);\n  offset += 4;\n  var reserved = bin.readUint(data, offset);\n  offset += 4;\n  offset = svgDocIndexOffset + offset0;\n  var numEntries = bin.readUshort(data, offset);\n  offset += 2;\n\n  for (var i = 0; i < numEntries; i++) {\n    var startGlyphID = bin.readUshort(data, offset);\n    offset += 2;\n    var endGlyphID = bin.readUshort(data, offset);\n    offset += 2;\n    var svgDocOffset = bin.readUint(data, offset);\n    offset += 4;\n    var svgDocLength = bin.readUint(data, offset);\n    offset += 4;\n    var sbuf = new Uint8Array(data.buffer, offset0 + svgDocOffset + svgDocIndexOffset, svgDocLength);\n    var svg = bin.readUTF8(sbuf, 0, sbuf.length);\n\n    for (var f = startGlyphID; f <= endGlyphID; f++) {\n      obj.entries[f] = svg;\n    }\n  }\n\n  return obj;\n};\n\nTypr.SVG.toPath = function (str) {\n  var pth = {\n    cmds: [],\n    crds: []\n  };\n\n  if (str == null) {\n    return pth;\n  }\n\n  var prsr = new DOMParser();\n  var doc = prsr[\"parseFromString\"](str, \"image/svg+xml\");\n  var svg = doc.firstChild;\n\n  while (svg.tagName != \"svg\") {\n    svg = svg.nextSibling;\n  }\n\n  var vb = svg.getAttribute(\"viewBox\");\n\n  if (vb) {\n    vb = vb.trim().split(\" \").map(parseFloat);\n  } else {\n    vb = [0, 0, 1e3, 1e3];\n  }\n\n  Typr.SVG._toPath(svg.children, pth);\n\n  for (var i = 0; i < pth.crds.length; i += 2) {\n    var x = pth.crds[i],\n        y = pth.crds[i + 1];\n    x -= vb[0];\n    y -= vb[1];\n    y = -y;\n    pth.crds[i] = x;\n    pth.crds[i + 1] = y;\n  }\n\n  return pth;\n};\n\nTypr.SVG._toPath = function (nds, pth, fill) {\n  for (var ni = 0; ni < nds.length; ni++) {\n    var nd = nds[ni],\n        tn = nd.tagName;\n    var cfl = nd.getAttribute(\"fill\");\n\n    if (cfl == null) {\n      cfl = fill;\n    }\n\n    if (tn == \"g\") {\n      Typr.SVG._toPath(nd.children, pth, cfl);\n    } else if (tn == \"path\") {\n      pth.cmds.push(cfl ? cfl : \"#000000\");\n      var d = nd.getAttribute(\"d\");\n\n      var toks = Typr.SVG._tokens(d);\n\n      Typr.SVG._toksToPath(toks, pth);\n\n      pth.cmds.push(\"X\");\n    } else if (tn == \"defs\") ;else {\n      console.log(tn, nd);\n    }\n  }\n};\n\nTypr.SVG._tokens = function (d) {\n  var ts = [],\n      off = 0,\n      rn = false,\n      cn = \"\";\n\n  while (off < d.length) {\n    var cc = d.charCodeAt(off),\n        ch = d.charAt(off);\n    off++;\n    var isNum = 48 <= cc && cc <= 57 || ch == \".\" || ch == \"-\";\n\n    if (rn) {\n      if (ch == \"-\") {\n        ts.push(parseFloat(cn));\n        cn = ch;\n      } else if (isNum) {\n        cn += ch;\n      } else {\n        ts.push(parseFloat(cn));\n\n        if (ch != \",\" && ch != \" \") {\n          ts.push(ch);\n        }\n\n        rn = false;\n      }\n    } else {\n      if (isNum) {\n        cn = ch;\n        rn = true;\n      } else if (ch != \",\" && ch != \" \") {\n        ts.push(ch);\n      }\n    }\n  }\n\n  if (rn) {\n    ts.push(parseFloat(cn));\n  }\n\n  return ts;\n};\n\nTypr.SVG._toksToPath = function (ts, pth) {\n  var i = 0,\n      x = 0,\n      y = 0,\n      ox = 0,\n      oy = 0;\n  var pc = {\n    M: 2,\n    L: 2,\n    H: 1,\n    V: 1,\n    S: 4,\n    C: 6\n  };\n  var cmds = pth.cmds,\n      crds = pth.crds;\n\n  while (i < ts.length) {\n    var cmd = ts[i];\n    i++;\n\n    if (cmd == \"z\") {\n      cmds.push(\"Z\");\n      x = ox;\n      y = oy;\n    } else {\n      var cmu = cmd.toUpperCase();\n\n      var ps = pc[cmu],\n          reps = Typr.SVG._reps(ts, i, ps);\n\n      for (var j = 0; j < reps; j++) {\n        var xi = 0,\n            yi = 0;\n\n        if (cmd != cmu) {\n          xi = x;\n          yi = y;\n        }\n\n        if (cmu == \"M\") {\n          x = xi + ts[i++];\n          y = yi + ts[i++];\n          cmds.push(\"M\");\n          crds.push(x, y);\n          ox = x;\n          oy = y;\n        } else if (cmu == \"L\") {\n          x = xi + ts[i++];\n          y = yi + ts[i++];\n          cmds.push(\"L\");\n          crds.push(x, y);\n        } else if (cmu == \"H\") {\n          x = xi + ts[i++];\n          cmds.push(\"L\");\n          crds.push(x, y);\n        } else if (cmu == \"V\") {\n          y = yi + ts[i++];\n          cmds.push(\"L\");\n          crds.push(x, y);\n        } else if (cmu == \"C\") {\n          var x1 = xi + ts[i++],\n              y1 = yi + ts[i++],\n              x2 = xi + ts[i++],\n              y2 = yi + ts[i++],\n              x3 = xi + ts[i++],\n              y3 = yi + ts[i++];\n          cmds.push(\"C\");\n          crds.push(x1, y1, x2, y2, x3, y3);\n          x = x3;\n          y = y3;\n        } else if (cmu == \"S\") {\n          var co = Math.max(crds.length - 4, 0);\n          var x1 = x + x - crds[co],\n              y1 = y + y - crds[co + 1];\n          var x2 = xi + ts[i++],\n              y2 = yi + ts[i++],\n              x3 = xi + ts[i++],\n              y3 = yi + ts[i++];\n          cmds.push(\"C\");\n          crds.push(x1, y1, x2, y2, x3, y3);\n          x = x3;\n          y = y3;\n        } else {\n          console.log(\"Unknown SVG command \" + cmd);\n        }\n      }\n    }\n  }\n};\n\nTypr.SVG._reps = function (ts, off, ps) {\n  var i = off;\n\n  while (i < ts.length) {\n    if (typeof ts[i] == \"string\") {\n      break;\n    }\n\n    i += ps;\n  }\n\n  return (i - off) / ps;\n};\n\nif (Typr == null) {\n  Typr = {};\n}\n\nif (Typr.U == null) {\n  Typr.U = {};\n}\n\nTypr.U.codeToGlyph = function (font, code) {\n  var cmap = font.cmap;\n  var tind = -1;\n\n  if (cmap.p0e4 != null) {\n    tind = cmap.p0e4;\n  } else if (cmap.p3e1 != null) {\n    tind = cmap.p3e1;\n  } else if (cmap.p1e0 != null) {\n    tind = cmap.p1e0;\n  }\n\n  if (tind == -1) {\n    throw \"no familiar platform and encoding!\";\n  }\n\n  var tab = cmap.tables[tind];\n\n  if (tab.format == 0) {\n    if (code >= tab.map.length) {\n      return 0;\n    }\n\n    return tab.map[code];\n  } else if (tab.format == 4) {\n    var sind = -1;\n\n    for (var i = 0; i < tab.endCount.length; i++) {\n      if (code <= tab.endCount[i]) {\n        sind = i;\n        break;\n      }\n    }\n\n    if (sind == -1) {\n      return 0;\n    }\n\n    if (tab.startCount[sind] > code) {\n      return 0;\n    }\n\n    var gli = 0;\n\n    if (tab.idRangeOffset[sind] != 0) {\n      gli = tab.glyphIdArray[code - tab.startCount[sind] + (tab.idRangeOffset[sind] >> 1) - (tab.idRangeOffset.length - sind)];\n    } else {\n      gli = code + tab.idDelta[sind];\n    }\n\n    return gli & 65535;\n  } else if (tab.format == 12) {\n    if (code > tab.groups[tab.groups.length - 1][1]) {\n      return 0;\n    }\n\n    for (var i = 0; i < tab.groups.length; i++) {\n      var grp = tab.groups[i];\n\n      if (grp[0] <= code && code <= grp[1]) {\n        return grp[2] + (code - grp[0]);\n      }\n    }\n\n    return 0;\n  } else {\n    throw \"unknown cmap table format \" + tab.format;\n  }\n};\n\nTypr.U.glyphToPath = function (font, gid) {\n  var path = {\n    cmds: [],\n    crds: []\n  };\n\n  if (font.SVG && font.SVG.entries[gid]) {\n    var p = font.SVG.entries[gid];\n\n    if (p == null) {\n      return path;\n    }\n\n    if (typeof p == \"string\") {\n      p = Typr.SVG.toPath(p);\n      font.SVG.entries[gid] = p;\n    }\n\n    return p;\n  } else if (font.CFF) {\n    var state = {\n      x: 0,\n      y: 0,\n      stack: [],\n      nStems: 0,\n      haveWidth: false,\n      width: font.CFF.Private ? font.CFF.Private.defaultWidthX : 0,\n      open: false\n    };\n\n    Typr.U._drawCFF(font.CFF.CharStrings[gid], state, font.CFF, path);\n  } else if (font.glyf) {\n    Typr.U._drawGlyf(gid, font, path);\n  }\n\n  return path;\n};\n\nTypr.U._drawGlyf = function (gid, font, path) {\n  var gl = font.glyf[gid];\n\n  if (gl == null) {\n    gl = font.glyf[gid] = Typr.glyf._parseGlyf(font, gid);\n  }\n\n  if (gl != null) {\n    if (gl.noc > -1) {\n      Typr.U._simpleGlyph(gl, path);\n    } else {\n      Typr.U._compoGlyph(gl, font, path);\n    }\n  }\n};\n\nTypr.U._simpleGlyph = function (gl, p) {\n  for (var c = 0; c < gl.noc; c++) {\n    var i0 = c == 0 ? 0 : gl.endPts[c - 1] + 1;\n    var il = gl.endPts[c];\n\n    for (var i = i0; i <= il; i++) {\n      var pr = i == i0 ? il : i - 1;\n      var nx = i == il ? i0 : i + 1;\n      var onCurve = gl.flags[i] & 1;\n      var prOnCurve = gl.flags[pr] & 1;\n      var nxOnCurve = gl.flags[nx] & 1;\n      var x = gl.xs[i],\n          y = gl.ys[i];\n\n      if (i == i0) {\n        if (onCurve) {\n          if (prOnCurve) {\n            Typr.U.P.moveTo(p, gl.xs[pr], gl.ys[pr]);\n          } else {\n            Typr.U.P.moveTo(p, x, y);\n            continue;\n          }\n        } else {\n          if (prOnCurve) {\n            Typr.U.P.moveTo(p, gl.xs[pr], gl.ys[pr]);\n          } else {\n            Typr.U.P.moveTo(p, (gl.xs[pr] + x) / 2, (gl.ys[pr] + y) / 2);\n          }\n        }\n      }\n\n      if (onCurve) {\n        if (prOnCurve) {\n          Typr.U.P.lineTo(p, x, y);\n        }\n      } else {\n        if (nxOnCurve) {\n          Typr.U.P.qcurveTo(p, x, y, gl.xs[nx], gl.ys[nx]);\n        } else {\n          Typr.U.P.qcurveTo(p, x, y, (x + gl.xs[nx]) / 2, (y + gl.ys[nx]) / 2);\n        }\n      }\n    }\n\n    Typr.U.P.closePath(p);\n  }\n};\n\nTypr.U._compoGlyph = function (gl, font, p) {\n  for (var j = 0; j < gl.parts.length; j++) {\n    var path = {\n      cmds: [],\n      crds: []\n    };\n    var prt = gl.parts[j];\n\n    Typr.U._drawGlyf(prt.glyphIndex, font, path);\n\n    var m = prt.m;\n\n    for (var i = 0; i < path.crds.length; i += 2) {\n      var x = path.crds[i],\n          y = path.crds[i + 1];\n      p.crds.push(x * m.a + y * m.b + m.tx);\n      p.crds.push(x * m.c + y * m.d + m.ty);\n    }\n\n    for (var i = 0; i < path.cmds.length; i++) {\n      p.cmds.push(path.cmds[i]);\n    }\n  }\n};\n\nTypr.U._getGlyphClass = function (g, cd) {\n  var intr = Typr._lctf.getInterval(cd, g);\n\n  return intr == -1 ? 0 : cd[intr + 2];\n};\n\nTypr.U.getPairAdjustment = function (font, g1, g2) {\n  if (font.GPOS) {\n    var ltab = null;\n\n    for (var i = 0; i < font.GPOS.featureList.length; i++) {\n      var fl = font.GPOS.featureList[i];\n\n      if (fl.tag == \"kern\") {\n        for (var j = 0; j < fl.tab.length; j++) {\n          if (font.GPOS.lookupList[fl.tab[j]].ltype == 2) {\n            ltab = font.GPOS.lookupList[fl.tab[j]];\n          }\n        }\n      }\n    }\n\n    if (ltab) {\n      for (var i = 0; i < ltab.tabs.length; i++) {\n        var tab = ltab.tabs[i];\n\n        var ind = Typr._lctf.coverageIndex(tab.coverage, g1);\n\n        if (ind == -1) {\n          continue;\n        }\n\n        var adj;\n\n        if (tab.format == 1) {\n          var right = tab.pairsets[ind];\n\n          for (var j = 0; j < right.length; j++) {\n            if (right[j].gid2 == g2) {\n              adj = right[j];\n            }\n          }\n\n          if (adj == null) {\n            continue;\n          }\n        } else if (tab.format == 2) {\n          var c1 = Typr.U._getGlyphClass(g1, tab.classDef1);\n\n          var c2 = Typr.U._getGlyphClass(g2, tab.classDef2);\n\n          var adj = tab.matrix[c1][c2];\n        }\n\n        return adj.val1[2];\n      }\n    }\n  }\n\n  if (font.kern) {\n    var ind1 = font.kern.glyph1.indexOf(g1);\n\n    if (ind1 != -1) {\n      var ind2 = font.kern.rval[ind1].glyph2.indexOf(g2);\n\n      if (ind2 != -1) {\n        return font.kern.rval[ind1].vals[ind2];\n      }\n    }\n  }\n\n  return 0;\n};\n\nTypr.U.stringToGlyphs = function (font, str) {\n  var gls = [];\n\n  for (var i = 0; i < str.length; i++) {\n    var cc = str.codePointAt(i);\n\n    if (cc > 65535) {\n      i++;\n    }\n\n    gls.push(Typr.U.codeToGlyph(font, cc));\n  }\n\n  var gsub = font[\"GSUB\"];\n\n  if (gsub == null) {\n    return gls;\n  }\n\n  var llist = gsub.lookupList,\n      flist = gsub.featureList;\n  var wsep = '\\n\\t\" ,.:;!?()  ';\n  var R = \"\";\n  var L = \"\";\n\n  for (var ci = 0; ci < gls.length; ci++) {\n    var gl = gls[ci];\n    var slft = ci == 0 || wsep.indexOf(str[ci - 1]) != -1;\n    var srgt = ci == gls.length - 1 || wsep.indexOf(str[ci + 1]) != -1;\n\n    if (!slft && R.indexOf(str[ci - 1]) != -1) {\n      slft = true;\n    }\n\n    if (!srgt && R.indexOf(str[ci]) != -1) {\n      srgt = true;\n    }\n\n    if (!srgt && L.indexOf(str[ci + 1]) != -1) {\n      srgt = true;\n    }\n\n    if (!slft && L.indexOf(str[ci]) != -1) {\n      slft = true;\n    }\n\n    var feat = null;\n\n    if (slft) {\n      feat = srgt ? \"isol\" : \"init\";\n    } else {\n      feat = srgt ? \"fina\" : \"medi\";\n    }\n\n    for (var fi = 0; fi < flist.length; fi++) {\n      if (flist[fi].tag != feat) {\n        continue;\n      }\n\n      for (var ti = 0; ti < flist[fi].tab.length; ti++) {\n        var tab = llist[flist[fi].tab[ti]];\n\n        if (tab.ltype != 1) {\n          continue;\n        }\n\n        Typr.U._applyType1(gls, ci, tab);\n      }\n    }\n  }\n\n  var cligs = [\"rlig\", \"liga\", \"mset\"];\n\n  for (var ci = 0; ci < gls.length; ci++) {\n    var gl = gls[ci];\n    var rlim = Math.min(3, gls.length - ci - 1);\n\n    for (var fi = 0; fi < flist.length; fi++) {\n      var fl = flist[fi];\n\n      if (cligs.indexOf(fl.tag) == -1) {\n        continue;\n      }\n\n      for (var ti = 0; ti < fl.tab.length; ti++) {\n        var tab = llist[fl.tab[ti]];\n\n        for (var j = 0; j < tab.tabs.length; j++) {\n          if (tab.tabs[j] == null) {\n            continue;\n          }\n\n          var ind = Typr._lctf.coverageIndex(tab.tabs[j].coverage, gl);\n\n          if (ind == -1) {\n            continue;\n          }\n\n          if (tab.ltype == 4) {\n            var vals = tab.tabs[j].vals[ind];\n\n            for (var k = 0; k < vals.length; k++) {\n              var lig = vals[k],\n                  rl = lig.chain.length;\n\n              if (rl > rlim) {\n                continue;\n              }\n\n              var good = true;\n\n              for (var l = 0; l < rl; l++) {\n                if (lig.chain[l] != gls[ci + (1 + l)]) {\n                  good = false;\n                }\n              }\n\n              if (!good) {\n                continue;\n              }\n\n              gls[ci] = lig.nglyph;\n\n              for (var l = 0; l < rl; l++) {\n                gls[ci + l + 1] = -1;\n              }\n            }\n          } else if (tab.ltype == 5) {\n            var ltab = tab.tabs[j];\n\n            if (ltab.fmt != 2) {\n              continue;\n            }\n\n            var cind = Typr._lctf.getInterval(ltab.cDef, gl);\n\n            var cls = ltab.cDef[cind + 2],\n                scs = ltab.scset[cls];\n\n            for (var i = 0; i < scs.length; i++) {\n              var sc = scs[i],\n                  inp = sc.input;\n\n              if (inp.length > rlim) {\n                continue;\n              }\n\n              var good = true;\n\n              for (var l = 0; l < inp.length; l++) {\n                var cind2 = Typr._lctf.getInterval(ltab.cDef, gls[ci + 1 + l]);\n\n                if (cind == -1 && ltab.cDef[cind2 + 2] != inp[l]) {\n                  good = false;\n                  break;\n                }\n              }\n\n              if (!good) {\n                continue;\n              }\n\n              var lrs = sc.substLookupRecords;\n\n              for (var k = 0; k < lrs.length; k += 2) {\n                var gi = lrs[k],\n                    tabi = lrs[k + 1];\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return gls;\n};\n\nTypr.U._applyType1 = function (gls, ci, tab) {\n  var gl = gls[ci];\n\n  for (var j = 0; j < tab.tabs.length; j++) {\n    var ttab = tab.tabs[j];\n\n    var ind = Typr._lctf.coverageIndex(ttab.coverage, gl);\n\n    if (ind == -1) {\n      continue;\n    }\n\n    if (ttab.fmt == 1) {\n      gls[ci] = gls[ci] + ttab.delta;\n    } else {\n      gls[ci] = ttab.newg[ind];\n    }\n  }\n};\n\nTypr.U.glyphsToPath = function (font, gls, clr) {\n  var tpath = {\n    cmds: [],\n    crds: []\n  };\n  var x = 0;\n\n  for (var i = 0; i < gls.length; i++) {\n    var gid = gls[i];\n\n    if (gid == -1) {\n      continue;\n    }\n\n    var gid2 = i < gls.length - 1 && gls[i + 1] != -1 ? gls[i + 1] : 0;\n    var path = Typr.U.glyphToPath(font, gid);\n\n    for (var j = 0; j < path.crds.length; j += 2) {\n      tpath.crds.push(path.crds[j] + x);\n      tpath.crds.push(path.crds[j + 1]);\n    }\n\n    if (clr) {\n      tpath.cmds.push(clr);\n    }\n\n    for (var j = 0; j < path.cmds.length; j++) {\n      tpath.cmds.push(path.cmds[j]);\n    }\n\n    if (clr) {\n      tpath.cmds.push(\"X\");\n    }\n\n    x += font.hmtx.aWidth[gid];\n\n    if (i < gls.length - 1) {\n      x += Typr.U.getPairAdjustment(font, gid, gid2);\n    }\n  }\n\n  return tpath;\n};\n\nTypr.U.pathToSVG = function (path, prec) {\n  if (prec == null) {\n    prec = 5;\n  }\n\n  var out = [],\n      co = 0,\n      lmap = {\n    M: 2,\n    L: 2,\n    Q: 4,\n    C: 6\n  };\n\n  for (var i = 0; i < path.cmds.length; i++) {\n    var cmd = path.cmds[i],\n        cn = co + (lmap[cmd] ? lmap[cmd] : 0);\n    out.push(cmd);\n\n    while (co < cn) {\n      var c = path.crds[co++];\n      out.push(parseFloat(c.toFixed(prec)) + (co == cn ? \"\" : \" \"));\n    }\n  }\n\n  return out.join(\"\");\n};\n\nTypr.U.pathToContext = function (path, ctx) {\n  var c = 0,\n      crds = path.crds;\n\n  for (var j = 0; j < path.cmds.length; j++) {\n    var cmd = path.cmds[j];\n\n    if (cmd == \"M\") {\n      ctx.moveTo(crds[c], crds[c + 1]);\n      c += 2;\n    } else if (cmd == \"L\") {\n      ctx.lineTo(crds[c], crds[c + 1]);\n      c += 2;\n    } else if (cmd == \"C\") {\n      ctx.bezierCurveTo(crds[c], crds[c + 1], crds[c + 2], crds[c + 3], crds[c + 4], crds[c + 5]);\n      c += 6;\n    } else if (cmd == \"Q\") {\n      ctx.quadraticCurveTo(crds[c], crds[c + 1], crds[c + 2], crds[c + 3]);\n      c += 4;\n    } else if (cmd.charAt(0) == \"#\") {\n      ctx.beginPath();\n      ctx.fillStyle = cmd;\n    } else if (cmd == \"Z\") {\n      ctx.closePath();\n    } else if (cmd == \"X\") {\n      ctx.fill();\n    }\n  }\n};\n\nTypr.U.P = {};\n\nTypr.U.P.moveTo = function (p, x, y) {\n  p.cmds.push(\"M\");\n  p.crds.push(x, y);\n};\n\nTypr.U.P.lineTo = function (p, x, y) {\n  p.cmds.push(\"L\");\n  p.crds.push(x, y);\n};\n\nTypr.U.P.curveTo = function (p, a, b, c, d, e, f) {\n  p.cmds.push(\"C\");\n  p.crds.push(a, b, c, d, e, f);\n};\n\nTypr.U.P.qcurveTo = function (p, a, b, c, d) {\n  p.cmds.push(\"Q\");\n  p.crds.push(a, b, c, d);\n};\n\nTypr.U.P.closePath = function (p) {\n  p.cmds.push(\"Z\");\n};\n\nTypr.U._drawCFF = function (cmds, state, font, p) {\n  var stack = state.stack;\n  var nStems = state.nStems,\n      haveWidth = state.haveWidth,\n      width = state.width,\n      open = state.open;\n  var i = 0;\n  var x = state.x,\n      y = state.y,\n      c1x = 0,\n      c1y = 0,\n      c2x = 0,\n      c2y = 0,\n      c3x = 0,\n      c3y = 0,\n      c4x = 0,\n      c4y = 0,\n      jpx = 0,\n      jpy = 0;\n  var o = {\n    val: 0,\n    size: 0\n  };\n\n  while (i < cmds.length) {\n    Typr.CFF.getCharString(cmds, i, o);\n    var v = o.val;\n    i += o.size;\n\n    if (v == \"o1\" || v == \"o18\") {\n      var hasWidthArg;\n      hasWidthArg = stack.length % 2 !== 0;\n\n      if (hasWidthArg && !haveWidth) {\n        width = stack.shift() + font.Private.nominalWidthX;\n      }\n\n      nStems += stack.length >> 1;\n      stack.length = 0;\n      haveWidth = true;\n    } else if (v == \"o3\" || v == \"o23\") {\n      var hasWidthArg;\n      hasWidthArg = stack.length % 2 !== 0;\n\n      if (hasWidthArg && !haveWidth) {\n        width = stack.shift() + font.Private.nominalWidthX;\n      }\n\n      nStems += stack.length >> 1;\n      stack.length = 0;\n      haveWidth = true;\n    } else if (v == \"o4\") {\n      if (stack.length > 1 && !haveWidth) {\n        width = stack.shift() + font.Private.nominalWidthX;\n        haveWidth = true;\n      }\n\n      if (open) {\n        Typr.U.P.closePath(p);\n      }\n\n      y += stack.pop();\n      Typr.U.P.moveTo(p, x, y);\n      open = true;\n    } else if (v == \"o5\") {\n      while (stack.length > 0) {\n        x += stack.shift();\n        y += stack.shift();\n        Typr.U.P.lineTo(p, x, y);\n      }\n    } else if (v == \"o6\" || v == \"o7\") {\n      var count = stack.length;\n      var isX = v == \"o6\";\n\n      for (var j = 0; j < count; j++) {\n        var sval = stack.shift();\n\n        if (isX) {\n          x += sval;\n        } else {\n          y += sval;\n        }\n\n        isX = !isX;\n        Typr.U.P.lineTo(p, x, y);\n      }\n    } else if (v == \"o8\" || v == \"o24\") {\n      var count = stack.length;\n      var index = 0;\n\n      while (index + 6 <= count) {\n        c1x = x + stack.shift();\n        c1y = y + stack.shift();\n        c2x = c1x + stack.shift();\n        c2y = c1y + stack.shift();\n        x = c2x + stack.shift();\n        y = c2y + stack.shift();\n        Typr.U.P.curveTo(p, c1x, c1y, c2x, c2y, x, y);\n        index += 6;\n      }\n\n      if (v == \"o24\") {\n        x += stack.shift();\n        y += stack.shift();\n        Typr.U.P.lineTo(p, x, y);\n      }\n    } else if (v == \"o11\") {\n      break;\n    } else if (v == \"o1234\" || v == \"o1235\" || v == \"o1236\" || v == \"o1237\") {\n      if (v == \"o1234\") {\n        c1x = x + stack.shift();\n        c1y = y;\n        c2x = c1x + stack.shift();\n        c2y = c1y + stack.shift();\n        jpx = c2x + stack.shift();\n        jpy = c2y;\n        c3x = jpx + stack.shift();\n        c3y = c2y;\n        c4x = c3x + stack.shift();\n        c4y = y;\n        x = c4x + stack.shift();\n        Typr.U.P.curveTo(p, c1x, c1y, c2x, c2y, jpx, jpy);\n        Typr.U.P.curveTo(p, c3x, c3y, c4x, c4y, x, y);\n      }\n\n      if (v == \"o1235\") {\n        c1x = x + stack.shift();\n        c1y = y + stack.shift();\n        c2x = c1x + stack.shift();\n        c2y = c1y + stack.shift();\n        jpx = c2x + stack.shift();\n        jpy = c2y + stack.shift();\n        c3x = jpx + stack.shift();\n        c3y = jpy + stack.shift();\n        c4x = c3x + stack.shift();\n        c4y = c3y + stack.shift();\n        x = c4x + stack.shift();\n        y = c4y + stack.shift();\n        stack.shift();\n        Typr.U.P.curveTo(p, c1x, c1y, c2x, c2y, jpx, jpy);\n        Typr.U.P.curveTo(p, c3x, c3y, c4x, c4y, x, y);\n      }\n\n      if (v == \"o1236\") {\n        c1x = x + stack.shift();\n        c1y = y + stack.shift();\n        c2x = c1x + stack.shift();\n        c2y = c1y + stack.shift();\n        jpx = c2x + stack.shift();\n        jpy = c2y;\n        c3x = jpx + stack.shift();\n        c3y = c2y;\n        c4x = c3x + stack.shift();\n        c4y = c3y + stack.shift();\n        x = c4x + stack.shift();\n        Typr.U.P.curveTo(p, c1x, c1y, c2x, c2y, jpx, jpy);\n        Typr.U.P.curveTo(p, c3x, c3y, c4x, c4y, x, y);\n      }\n\n      if (v == \"o1237\") {\n        c1x = x + stack.shift();\n        c1y = y + stack.shift();\n        c2x = c1x + stack.shift();\n        c2y = c1y + stack.shift();\n        jpx = c2x + stack.shift();\n        jpy = c2y + stack.shift();\n        c3x = jpx + stack.shift();\n        c3y = jpy + stack.shift();\n        c4x = c3x + stack.shift();\n        c4y = c3y + stack.shift();\n\n        if (Math.abs(c4x - x) > Math.abs(c4y - y)) {\n          x = c4x + stack.shift();\n        } else {\n          y = c4y + stack.shift();\n        }\n\n        Typr.U.P.curveTo(p, c1x, c1y, c2x, c2y, jpx, jpy);\n        Typr.U.P.curveTo(p, c3x, c3y, c4x, c4y, x, y);\n      }\n    } else if (v == \"o14\") {\n      if (stack.length > 0 && !haveWidth) {\n        width = stack.shift() + font.nominalWidthX;\n        haveWidth = true;\n      }\n\n      if (stack.length == 4) {\n        var adx = stack.shift();\n        var ady = stack.shift();\n        var bchar = stack.shift();\n        var achar = stack.shift();\n        var bind = Typr.CFF.glyphBySE(font, bchar);\n        var aind = Typr.CFF.glyphBySE(font, achar);\n\n        Typr.U._drawCFF(font.CharStrings[bind], state, font, p);\n\n        state.x = adx;\n        state.y = ady;\n\n        Typr.U._drawCFF(font.CharStrings[aind], state, font, p);\n      }\n\n      if (open) {\n        Typr.U.P.closePath(p);\n        open = false;\n      }\n    } else if (v == \"o19\" || v == \"o20\") {\n      var hasWidthArg;\n      hasWidthArg = stack.length % 2 !== 0;\n\n      if (hasWidthArg && !haveWidth) {\n        width = stack.shift() + font.Private.nominalWidthX;\n      }\n\n      nStems += stack.length >> 1;\n      stack.length = 0;\n      haveWidth = true;\n      i += nStems + 7 >> 3;\n    } else if (v == \"o21\") {\n      if (stack.length > 2 && !haveWidth) {\n        width = stack.shift() + font.Private.nominalWidthX;\n        haveWidth = true;\n      }\n\n      y += stack.pop();\n      x += stack.pop();\n\n      if (open) {\n        Typr.U.P.closePath(p);\n      }\n\n      Typr.U.P.moveTo(p, x, y);\n      open = true;\n    } else if (v == \"o22\") {\n      if (stack.length > 1 && !haveWidth) {\n        width = stack.shift() + font.Private.nominalWidthX;\n        haveWidth = true;\n      }\n\n      x += stack.pop();\n\n      if (open) {\n        Typr.U.P.closePath(p);\n      }\n\n      Typr.U.P.moveTo(p, x, y);\n      open = true;\n    } else if (v == \"o25\") {\n      while (stack.length > 6) {\n        x += stack.shift();\n        y += stack.shift();\n        Typr.U.P.lineTo(p, x, y);\n      }\n\n      c1x = x + stack.shift();\n      c1y = y + stack.shift();\n      c2x = c1x + stack.shift();\n      c2y = c1y + stack.shift();\n      x = c2x + stack.shift();\n      y = c2y + stack.shift();\n      Typr.U.P.curveTo(p, c1x, c1y, c2x, c2y, x, y);\n    } else if (v == \"o26\") {\n      if (stack.length % 2) {\n        x += stack.shift();\n      }\n\n      while (stack.length > 0) {\n        c1x = x;\n        c1y = y + stack.shift();\n        c2x = c1x + stack.shift();\n        c2y = c1y + stack.shift();\n        x = c2x;\n        y = c2y + stack.shift();\n        Typr.U.P.curveTo(p, c1x, c1y, c2x, c2y, x, y);\n      }\n    } else if (v == \"o27\") {\n      if (stack.length % 2) {\n        y += stack.shift();\n      }\n\n      while (stack.length > 0) {\n        c1x = x + stack.shift();\n        c1y = y;\n        c2x = c1x + stack.shift();\n        c2y = c1y + stack.shift();\n        x = c2x + stack.shift();\n        y = c2y;\n        Typr.U.P.curveTo(p, c1x, c1y, c2x, c2y, x, y);\n      }\n    } else if (v == \"o10\" || v == \"o29\") {\n      var obj = v == \"o10\" ? font.Private : font;\n\n      if (stack.length == 0) {\n        console.log(\"error: empty stack\");\n      } else {\n        var ind = stack.pop();\n        var subr = obj.Subrs[ind + obj.Bias];\n        state.x = x;\n        state.y = y;\n        state.nStems = nStems;\n        state.haveWidth = haveWidth;\n        state.width = width;\n        state.open = open;\n\n        Typr.U._drawCFF(subr, state, font, p);\n\n        x = state.x;\n        y = state.y;\n        nStems = state.nStems;\n        haveWidth = state.haveWidth;\n        width = state.width;\n        open = state.open;\n      }\n    } else if (v == \"o30\" || v == \"o31\") {\n      var count,\n          count1 = stack.length;\n      var index = 0;\n      var alternate = v == \"o31\";\n      count = count1 & ~2;\n      index += count1 - count;\n\n      while (index < count) {\n        if (alternate) {\n          c1x = x + stack.shift();\n          c1y = y;\n          c2x = c1x + stack.shift();\n          c2y = c1y + stack.shift();\n          y = c2y + stack.shift();\n\n          if (count - index == 5) {\n            x = c2x + stack.shift();\n            index++;\n          } else {\n            x = c2x;\n          }\n\n          alternate = false;\n        } else {\n          c1x = x;\n          c1y = y + stack.shift();\n          c2x = c1x + stack.shift();\n          c2y = c1y + stack.shift();\n          x = c2x + stack.shift();\n\n          if (count - index == 5) {\n            y = c2y + stack.shift();\n            index++;\n          } else {\n            y = c2y;\n          }\n\n          alternate = true;\n        }\n\n        Typr.U.P.curveTo(p, c1x, c1y, c2x, c2y, x, y);\n        index += 4;\n      }\n    } else if ((v + \"\").charAt(0) == \"o\") {\n      console.log(\"Unknown operation: \" + v, cmds);\n      throw v;\n    } else {\n      stack.push(v);\n    }\n  }\n\n  state.x = x;\n  state.y = y;\n  state.nStems = nStems;\n  state.haveWidth = haveWidth;\n  state.width = width;\n  state.open = open;\n};\n\nvar typr_js = Typr;\nvar TEXT_NEWLINE_REGEXP = /\\r?\\n/;\n\nfunction registerFontClass(Zdog) {\n  // Zdog.Font class\n  var ZdogFont = function ZdogFont(props) {\n    var this$1 = this; // Set missing props to default values\n\n    props = Zdog.extend({\n      src: ''\n    }, props);\n    this.src = props.src;\n    this.font = null;\n    this._hasLoaded = false;\n    this._loadCallbacks = []; // Add this font instance to the internal font list\n\n    Zdog.FontList.push(this); // Begin loading font file\n\n    this._fetchFontResource(this.src).then(function (buffer) {\n      var font = typr_js.parse(buffer); // check font fields to see if the font was parsed correctly\n\n      if (!font.head || !font.hmtx || !font.hhea || !font.glyf) {\n        // get a list of missing font fields (only checks for ones that zfont uses)\n        var missingFields = ['head', 'hmtx', 'hhea', 'glyf'].filter(function (field) {\n          return !font[field];\n        });\n        throw new Error(\"Typr.js could not parse this font (unable to find \" + missingFields.join(', ') + \")\");\n      }\n\n      return font;\n    }).then(function (font) {\n      this$1.font = font;\n      this$1._hasLoaded = true;\n\n      this$1._loadCallbacks.forEach(function (callback) {\n        return callback();\n      });\n    }).catch(function (err) {\n      throw new Error(\"Unable to load font from \" + this$1.src + \":\\n\" + err);\n    });\n  };\n\n  ZdogFont.prototype.waitForLoad = function waitForLoad() {\n    var this$1 = this;\n    return new Promise(function (resolve, reject) {\n      // If the font is loaded, we can resolve right away\n      if (this$1._hasLoaded && this$1._hasLoaded) {\n        resolve();\n      } // Otherwise, wait for it to load\n      else {\n          this$1._loadCallbacks.push(resolve);\n        }\n    });\n  };\n\n  ZdogFont.prototype.getFontScale = function getFontScale(fontSize) {\n    if (!this._hasLoaded) {\n      return null;\n    } else {\n      return 1 / this.font.head.unitsPerEm * fontSize;\n    }\n  };\n\n  ZdogFont.prototype.measureText = function measureText(text, fontSize) {\n    var this$1 = this;\n    if (fontSize === void 0) fontSize = 64;\n\n    if (!this._hasLoaded) {\n      return null;\n    }\n\n    var lines = Array.isArray(text) ? text : text.split(TEXT_NEWLINE_REGEXP);\n    var font = this.font;\n    var advanceWidthTable = font.hmtx.aWidth;\n    var fontScale = this.getFontScale(fontSize);\n    var descender = font.hhea.descender;\n    var ascender = font.hhea.ascender;\n    var lineGap = font.hhea.lineGap;\n    var lineWidths = lines.map(function (line) {\n      var glyphs = typr_js.U.stringToGlyphs(this$1.font, line);\n      return glyphs.reduce(function (advanceWidth, glyphId) {\n        // stringToGlyphs returns an array on glyph IDs that is the same length as the text string\n        // an ID can sometimes be -1 in cases where multiple characters are merged into a single ligature\n        if (glyphId > -1 && glyphId < advanceWidthTable.length) {\n          advanceWidth += advanceWidthTable[glyphId];\n        }\n\n        return advanceWidth;\n      }, 0);\n    });\n    var width = Math.max.apply(Math, lineWidths);\n    var lineHeight = 0 - descender + ascender;\n    var height = lineHeight * lines.length; // Multiply by fontScale to convert from font units to pixels\n\n    return {\n      width: width * fontScale,\n      height: height * fontScale,\n      lineHeight: lineHeight * fontScale,\n      lineWidths: lineWidths.map(function (width) {\n        return width * fontScale;\n      }),\n      descender: descender * fontScale,\n      ascender: ascender * fontScale\n    };\n  };\n\n  ZdogFont.prototype.getTextPath = function getTextPath(text, fontSize, x, y, z, alignX, alignY) {\n    var this$1 = this;\n    if (fontSize === void 0) fontSize = 64;\n    if (x === void 0) x = 0;\n    if (y === void 0) y = 0;\n    if (z === void 0) z = 0;\n    if (alignX === void 0) alignX = 'left';\n    if (alignY === void 0) alignY = 'bottom';\n\n    if (!this._hasLoaded) {\n      return [];\n    }\n\n    var lines = Array.isArray(text) ? text : text.split(TEXT_NEWLINE_REGEXP);\n    var measurements = this.measureText(text, fontSize);\n    var lineWidths = measurements.lineWidths;\n    var lineHeight = measurements.lineHeight;\n    return lines.map(function (line, lineIndex) {\n      var ref = this$1.getTextOrigin(Object.assign({}, measurements, {\n        width: lineWidths[lineIndex]\n      }), x, y, z, alignX, alignY);\n      var _x = ref[0];\n      var _y = ref[1];\n      var _z = ref[2];\n      y += lineHeight;\n      var glyphs = typr_js.U.stringToGlyphs(this$1.font, line);\n      var path = typr_js.U.glyphsToPath(this$1.font, glyphs);\n      return this$1._convertPathCommands(path, fontSize, _x, _y, z);\n    }).flat();\n  };\n\n  ZdogFont.prototype.getTextGlyphs = function getTextGlyphs(text, fontSize, x, y, z, alignX, alignY) {\n    var this$1 = this;\n    if (fontSize === void 0) fontSize = 64;\n    if (x === void 0) x = 0;\n    if (y === void 0) y = 0;\n    if (z === void 0) z = 0;\n    if (alignX === void 0) alignX = 'left';\n    if (alignY === void 0) alignY = 'bottom';\n\n    if (!this._hasLoaded) {\n      return [];\n    }\n\n    var measurements = this.measureText(text, fontSize);\n    var advanceWidthTable = this.font.hmtx.aWidth;\n    var fontScale = this.getFontScale(fontSize);\n    var lineWidths = measurements.lineWidths;\n    var lineHeight = measurements.lineHeight;\n    var lines = Array.isArray(text) ? text : text.split(TEXT_NEWLINE_REGEXP);\n    return lines.map(function (line, lineIndex) {\n      var glyphs = typr_js.U.stringToGlyphs(this$1.font, line);\n      var ref = this$1.getTextOrigin(Object.assign({}, measurements, {\n        width: lineWidths[lineIndex]\n      }), x, y, z, alignX, alignY);\n      var _x = ref[0];\n      var _y = ref[1];\n      var _z = ref[2];\n      y += lineHeight;\n      return glyphs.filter(function (glyph) {\n        return glyph !== -1;\n      }).map(function (glyphId) {\n        var path = typr_js.U.glyphToPath(this$1.font, glyphId);\n        var shape = {\n          translate: {\n            x: _x,\n            y: _y,\n            z: _z\n          },\n          path: this$1._convertPathCommands(path, fontSize, 0, 0, 0)\n        };\n        _x += advanceWidthTable[glyphId] * fontScale;\n        return shape;\n      });\n    }).flat();\n  };\n\n  ZdogFont.prototype.getTextOrigin = function getTextOrigin(measuement, x, y, z, alignX, alignY) {\n    if (x === void 0) x = 0;\n    if (y === void 0) y = 0;\n    if (z === void 0) z = 0;\n    if (alignX === void 0) alignX = 'left';\n    if (alignY === void 0) alignY = 'bottom';\n    var width = measuement.width;\n    var height = measuement.height;\n    var lineHeight = measuement.lineHeight;\n\n    switch (alignX) {\n      case 'right':\n        x -= width;\n        break;\n\n      case 'center':\n        x -= width / 2;\n        break;\n\n      default:\n        break;\n    }\n\n    switch (alignY) {\n      case 'middle':\n        y -= height / 2 - lineHeight;\n        break;\n\n      case 'bottom':\n      default:\n        y -= height - lineHeight;\n        break;\n    }\n\n    return [x, y, z];\n  }; // Convert Typr.js path commands to Zdog commands\n  // Also apply font size scaling and coordinate adjustment\n  // https://github.com/photopea/Typr.js\n  // https://zzz.dog/shapes#shape-path-commands\n\n\n  ZdogFont.prototype._convertPathCommands = function _convertPathCommands(path, fontSize, x, y, z) {\n    if (x === void 0) x = 0;\n    if (y === void 0) y = 0;\n    if (z === void 0) z = 0;\n    var yDir = -1;\n    var xDir = 1;\n    var fontScale = this.getFontScale(fontSize);\n    var commands = path.cmds; // Apply font scale to all coords\n\n    var coords = path.crds.map(function (coord) {\n      return coord * fontScale;\n    }); // Convert coords to Zdog commands\n\n    var startCoord = null;\n    var coordOffset = 0;\n    return commands.map(function (cmd) {\n      var result = null;\n\n      if (!startCoord) {\n        startCoord = {\n          x: x + coords[coordOffset] * xDir,\n          y: y + coords[coordOffset + 1] * yDir,\n          z: z\n        };\n      }\n\n      switch (cmd) {\n        case 'M':\n          // moveTo command\n          result = {\n            move: {\n              x: x + coords[coordOffset] * xDir,\n              y: y + coords[coordOffset + 1] * yDir,\n              z: z\n            }\n          };\n          coordOffset += 2;\n          return result;\n\n        case 'L':\n          // lineTo command\n          result = {\n            line: {\n              x: x + coords[coordOffset] * xDir,\n              y: y + coords[coordOffset + 1] * yDir,\n              z: z\n            }\n          };\n          coordOffset += 2;\n          return result;\n\n        case 'C':\n          // curveTo command\n          result = {\n            bezier: [{\n              x: x + coords[coordOffset] * xDir,\n              y: y + coords[coordOffset + 1] * yDir,\n              z: z\n            }, {\n              x: x + coords[coordOffset + 2] * xDir,\n              y: y + coords[coordOffset + 3] * yDir,\n              z: z\n            }, {\n              x: x + coords[coordOffset + 4] * xDir,\n              y: y + coords[coordOffset + 5] * yDir,\n              z: z\n            }]\n          };\n          coordOffset += 6;\n          return result;\n\n        case 'Q':\n          // arcTo command\n          result = {\n            arc: [{\n              x: x + coords[coordOffset] * xDir,\n              y: y + coords[coordOffset + 1] * yDir,\n              z: z\n            }, {\n              x: x + coords[coordOffset + 2] * xDir,\n              y: y + coords[coordOffset + 3] * yDir,\n              z: z\n            }]\n          };\n          coordOffset += 4;\n          return result;\n\n        case 'Z':\n          // close path\n          if (startCoord) {\n            result = {\n              line: startCoord\n            };\n            startCoord = null;\n          }\n\n          return result;\n        // unhandled type\n        // currently, #rrggbb and X types (used in multicolor fonts) aren't supported\n\n        default:\n          return result;\n      }\n    }).filter(function (cmd) {\n      return cmd !== null;\n    }); // filter out null commands\n  };\n\n  ZdogFont.prototype._fetchFontResource = function _fetchFontResource(source) {\n    return new Promise(function (resolve, reject) {\n      var request = new XMLHttpRequest(); // Fetch as an arrayBuffer for Typr.parse\n\n      request.responseType = 'arraybuffer';\n      request.open('GET', source, true);\n\n      request.onreadystatechange = function (e) {\n        if (request.readyState === 4) {\n          if (request.status >= 200 && request.status < 300) {\n            resolve(request.response);\n          } else {\n            reject(\"HTTP error \" + request.status + \": \" + request.statusText);\n          }\n        }\n      };\n\n      request.send(null);\n    });\n  };\n\n  Zdog.Font = ZdogFont;\n  return Zdog;\n}\n\nfunction objectWithoutProperties(obj, exclude) {\n  var target = {};\n\n  for (var k in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];\n  }\n\n  return target;\n}\n\nfunction registerTextClass(Zdog) {\n  // Zdog.Text class\n  var ZdogText =\n  /*@__PURE__*/\n  function (superclass) {\n    function ZdogText(props) {\n      // Set missing props to default values\n      props = Zdog.extend({\n        font: null,\n        value: '',\n        fontSize: 64,\n        textAlign: 'left',\n        textBaseline: 'bottom'\n      }, props); // Split props\n\n      var font = props.font;\n      var value = props.value;\n      var fontSize = props.fontSize;\n      var textAlign = props.textAlign;\n      var textBaseline = props.textBaseline;\n      var rest = objectWithoutProperties(props, [\"font\", \"value\", \"fontSize\", \"textAlign\", \"textBaseline\"]);\n      var shapeProps = rest; // Create shape object\n\n      superclass.call(this, Object.assign({}, shapeProps, {\n        closed: true,\n        visible: false,\n        // hide until font is loaded\n        path: [{}]\n      }));\n      this._font = null;\n      this._value = value;\n      this._fontSize = fontSize;\n      this._textAlign = textAlign;\n      this._textBaseline = textBaseline;\n      this.font = font;\n    }\n\n    if (superclass) ZdogText.__proto__ = superclass;\n    ZdogText.prototype = Object.create(superclass && superclass.prototype);\n    ZdogText.prototype.constructor = ZdogText;\n    var prototypeAccessors = {\n      font: {\n        configurable: true\n      },\n      value: {\n        configurable: true\n      },\n      fontSize: {\n        configurable: true\n      },\n      textAlign: {\n        configurable: true\n      },\n      textBaseline: {\n        configurable: true\n      }\n    };\n\n    ZdogText.prototype.updateText = function updateText() {\n      var path = this.font.getTextPath(this.value, this.fontSize, 0, 0, 0, this.textAlign, this.textBaseline);\n\n      if (path.length == 0) {\n        // zdog doesn't know what to do with empty path arrays\n        this.path = [{}];\n        this.visible = false;\n      } else {\n        this.path = path;\n        this.visible = true;\n      }\n\n      this.updatePath();\n    };\n\n    prototypeAccessors.font.set = function (newFont) {\n      var this$1 = this;\n      this._font = newFont;\n      this.font.waitForLoad().then(function () {\n        this$1.updateText();\n        this$1.visible = true; // Find root Zdog.Illustration instance\n\n        var root = this$1.addTo;\n\n        while (root.addTo !== undefined) {\n          root = root.addTo;\n        } // Update render graph\n\n\n        if (root && typeof root.updateRenderGraph === 'function') {\n          root.updateRenderGraph();\n        }\n      });\n    };\n\n    prototypeAccessors.font.get = function () {\n      return this._font;\n    };\n\n    prototypeAccessors.value.set = function (newValue) {\n      this._value = newValue;\n      this.updateText();\n    };\n\n    prototypeAccessors.value.get = function () {\n      return this._value;\n    };\n\n    prototypeAccessors.fontSize.set = function (newSize) {\n      this._fontSize = newSize;\n      this.updateText();\n    };\n\n    prototypeAccessors.fontSize.get = function () {\n      return this._fontSize;\n    };\n\n    prototypeAccessors.textAlign.set = function (newValue) {\n      this._textAlign = newValue;\n      this.updateText();\n    };\n\n    prototypeAccessors.textAlign.get = function () {\n      return this._textAlign;\n    };\n\n    prototypeAccessors.textBaseline.set = function (newValue) {\n      this._textBaseline = newValue;\n      this.updateText();\n    };\n\n    prototypeAccessors.textBaseline.get = function () {\n      return this._textBaseline;\n    };\n\n    Object.defineProperties(ZdogText.prototype, prototypeAccessors);\n    return ZdogText;\n  }(Zdog.Shape);\n\n  ZdogText.optionKeys = ZdogText.optionKeys.concat(['font', 'fontSize', 'value', 'textAlign', 'textBaseline']);\n  Zdog.Text = ZdogText;\n  return Zdog;\n}\n\nfunction objectWithoutProperties$1(obj, exclude) {\n  var target = {};\n\n  for (var k in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];\n  }\n\n  return target;\n}\n\nfunction registerTextGroupClass(Zdog) {\n  // Zdog.TextGroup class\n  var ZdogTextGroup =\n  /*@__PURE__*/\n  function (superclass) {\n    function ZdogTextGroup(props) {\n      // Set missing props to default values\n      props = Zdog.extend({\n        font: null,\n        value: '',\n        fontSize: 64,\n        textAlign: 'left',\n        textBaseline: 'bottom',\n        color: '#333',\n        fill: false,\n        stroke: 1\n      }, props); // Split props\n\n      var font = props.font;\n      var value = props.value;\n      var fontSize = props.fontSize;\n      var textAlign = props.textAlign;\n      var textBaseline = props.textBaseline;\n      var color = props.color;\n      var fill = props.fill;\n      var stroke = props.stroke;\n      var rest = objectWithoutProperties$1(props, [\"font\", \"value\", \"fontSize\", \"textAlign\", \"textBaseline\", \"color\", \"fill\", \"stroke\"]);\n      var groupProps = rest; // Create group object\n\n      superclass.call(this, Object.assign({}, groupProps, {\n        visible: false\n      }));\n      this._font = null;\n      this._value = value;\n      this._fontSize = fontSize;\n      this._textAlign = textAlign;\n      this._textBaseline = textBaseline;\n      this._color = color;\n      this._fill = fill;\n      this._stroke = stroke;\n      this.font = font;\n    }\n\n    if (superclass) ZdogTextGroup.__proto__ = superclass;\n    ZdogTextGroup.prototype = Object.create(superclass && superclass.prototype);\n    ZdogTextGroup.prototype.constructor = ZdogTextGroup;\n    var prototypeAccessors = {\n      font: {\n        configurable: true\n      },\n      value: {\n        configurable: true\n      },\n      fontSize: {\n        configurable: true\n      },\n      textAlign: {\n        configurable: true\n      },\n      textBaseline: {\n        configurable: true\n      },\n      color: {\n        configurable: true\n      },\n      fill: {\n        configurable: true\n      },\n      stroke: {\n        configurable: true\n      }\n    };\n\n    ZdogTextGroup.prototype.updateText = function updateText() {\n      var this$1 = this; // Remove old children\n\n      while (this.children.length > 0) {\n        this.removeChild(this.children[0]);\n      } // Get text paths for each glyph\n\n\n      var glyphs = this.font.getTextGlyphs(this.value, this.fontSize, 0, 0, 0, this.textAlign, this.textBaseline); // Convert glyphs to new shapes\n\n      glyphs.filter(function (shape) {\n        return shape.path.length > 0;\n      }).forEach(function (shape) {\n        this$1.addChild(new Zdog.Shape({\n          translate: shape.translate,\n          path: shape.path,\n          color: this$1.color,\n          fill: this$1.fill,\n          stroke: this$1.stroke,\n          closed: true\n        }));\n      });\n      this.updateFlatGraph();\n    };\n\n    prototypeAccessors.font.set = function (newFont) {\n      var this$1 = this;\n      this._font = newFont;\n\n      this._font.waitForLoad().then(function () {\n        this$1.updateText();\n        this$1.visible = true; // Find root Zdog.Illustration instance\n\n        var root = this$1.addTo;\n\n        while (root.addTo !== undefined) {\n          root = root.addTo;\n        } // Update render graph\n\n\n        if (root && typeof root.updateRenderGraph === 'function') {\n          root.updateRenderGraph();\n        }\n      });\n    };\n\n    prototypeAccessors.font.get = function () {\n      return this._font;\n    };\n\n    prototypeAccessors.value.set = function (newValue) {\n      this._value = newValue;\n      this.updateText();\n    };\n\n    prototypeAccessors.value.get = function () {\n      return this._value;\n    };\n\n    prototypeAccessors.fontSize.set = function (newSize) {\n      this._fontSize = newSize;\n      this.updateText();\n    };\n\n    prototypeAccessors.fontSize.get = function () {\n      return this._fontSize;\n    };\n\n    prototypeAccessors.textAlign.set = function (newValue) {\n      this._textAlign = newValue;\n      this.updateText();\n    };\n\n    prototypeAccessors.textAlign.get = function () {\n      return this._textAlign;\n    };\n\n    prototypeAccessors.textBaseline.set = function (newValue) {\n      this._textBaseline = newValue;\n      this.updateText();\n    };\n\n    prototypeAccessors.textBaseline.get = function () {\n      return this._textBaseline;\n    };\n\n    prototypeAccessors.color.set = function (newColor) {\n      this._color = newColor;\n      this.children.forEach(function (child) {\n        return child.color = newColor;\n      });\n    };\n\n    prototypeAccessors.color.get = function () {\n      return this._color;\n    };\n\n    prototypeAccessors.fill.set = function (newFill) {\n      this._fill = newFill;\n      this.children.forEach(function (child) {\n        return child.fill = newFill;\n      });\n    };\n\n    prototypeAccessors.fill.get = function () {\n      return this._fill;\n    };\n\n    prototypeAccessors.stroke.set = function (newStroke) {\n      this._stroke = newStroke;\n      this.children.forEach(function (child) {\n        return child.stroke = newStroke;\n      });\n    };\n\n    prototypeAccessors.stroke.get = function () {\n      return this._stroke;\n    };\n\n    Object.defineProperties(ZdogTextGroup.prototype, prototypeAccessors);\n    return ZdogTextGroup;\n  }(Zdog.Group);\n\n  ZdogTextGroup.optionKeys = ZdogTextGroup.optionKeys.concat(['color', 'fill', 'stroke', 'font', 'fontSize', 'value', 'textAlign', 'textBaseline']);\n  Zdog.TextGroup = ZdogTextGroup;\n  return Zdog;\n}\n\nvar index = {\n  init: function init(Zdog) {\n    // Global font list to keep track of all fonts\n    Zdog.FontList = []; // Helper to wait for all fonts to load\n\n    Zdog.waitForFonts = function () {\n      return Promise.all(Zdog.FontList.map(function (font) {\n        return font.waitForLoad();\n      }));\n    }; // Register Zfont classes onto the Zdog object\n\n\n    registerFontClass(Zdog);\n    registerTextClass(Zdog);\n    registerTextGroupClass(Zdog);\n    return Zdog;\n  },\n  version: \"1.2.7\"\n};\nexport default index;","map":null,"metadata":{},"sourceType":"module"}